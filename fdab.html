<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frequency Domain Analysis in Biology - Interactive Demos</title>

    <!-- MathJax Configuration -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

    <!-- Complex.js -->
    <script src="https://cdn.jsdelivr.net/npm/complex.js@2.1.1/complex.min.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        serif: ['Lora', 'serif'],
                    },
                    colors: {
                        'spectral-blue': '#2563EB',
                        'spectral-purple': '#7C3AED',
                        'spectral-green': '#059669',
                        'spectral-red': '#DC2626',
                        'bio-bg': '#F8FAFC',
                        'bio-text': '#374151',
                        'bio-heading': '#1F2937',
                    }
                }
            }
        }
    </script>

    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <!-- Top Navigation Bar for page switching -->
    <div class="w-full bg-[#F0EBE3] border-b border-gray-300 flex items-center justify-center py-2 px-4">
        <nav class="flex space-x-6">
            <a href="index.html" class="text-spectral-purple font-semibold hover:underline">Fourier Foundations</a>
            <a href="fdab.html" class="text-spectral-purple font-semibold hover:underline">FDA Biology Explorer</a>
            <a href="bio.html" class="text-spectral-purple font-semibold hover:underline">BioXen Fourier Explorer</a>
        </nav>
    </div>
    <div class="flex flex-col md:flex-row min-h-screen">
    <nav class="w-full md:w-64 bg-[#F0EBE3] p-4 md:p-6 flex-shrink-0">
        <h2 class="text-2xl font-bold mb-6 text-center md:text-left">FDA Biology</h2>
        <ul id="navigation" class="space-y-2">
            <li><a href="#psd" class="nav-link block p-3 rounded-lg font-medium">PSD Analysis</a></li>
            <li><a href="#wavelet" class="nav-link block p-3 rounded-lg font-medium">Wavelet Analysis</a></li>
            <li><a href="#hosa" class="nav-link block p-3 rounded-lg font-medium">Higher-Order Spectra</a></li>
            <li><a href="#graphs" class="nav-link block p-3 rounded-lg font-medium">Graph Theory</a></li>
            <li><a href="#circadian" class="nav-link block p-3 rounded-lg font-medium">Circadian Analysis</a></li>
            <li><a href="#folding" class="nav-link block p-3 rounded-lg font-medium">Protein Folding</a></li>
            <li><a href="#transcription" class="nav-link block p-3 rounded-lg font-medium">DNA Transcription</a></li>
        </ul>
    </nav>

    <main class="flex-1 p-6 md:p-10 overflow-y-auto">

        <!-- Hero Section -->
        <section class="text-center mb-12">
            <h1 class="text-4xl md:text-6xl font-bold text-bio-heading mb-4">
                Interactive Frequency Domain Analysis
            </h1>
            <p class="text-xl text-bio-text mb-8">
                Explore advanced spectral techniques applied to biological systems. This platform demonstrates key concepts from the comprehensive review on Frequency Domain Analysis in Systems Biology.
            </p>
            <div class="bg-spectral-purple/10 border-l-4 border-spectral-purple p-6 rounded-r-lg">
                <h2 class="font-semibold text-bio-heading mb-2">Learning Objectives</h2>
                <p class="text-sm">Master spectral decomposition, wavelet analysis, higher-order statistics, and their applications to biological time series, networks, and omics data.</p>
            </div>
        </section>

        <!-- PSD Analysis Section -->
        <section id="psd" class="mb-16">
            <div class="bg-white rounded-lg shadow-lg p-8">
                <h2 class="text-3xl font-bold text-bio-heading mb-4">📊 Power Spectral Density & Phase Coherence</h2>
                <p class="text-bio-text mb-6">
                    The foundation of frequency domain analysis is the Power Spectral Density (PSD), which quantifies how power is distributed across different frequencies. Phase coherence measures the reliability of oscillatory components in stochastic biological systems.
                </p>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Signal Generation</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Signal Type</label>
                                <select id="signalType" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="sine">Pure Sine Wave</option>
                                    <option value="square">Square Wave</option>
                                    <option value="sawtooth">Sawtooth Wave</option>
                                    <option value="noise">White Noise</option>
                                    <option value="biological">Biological Rhythm</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Frequency (Hz): <span id="freqValue">1.0</span></label>
                                <input type="range" id="frequency" min="0.1" max="10" step="0.1" value="1.0" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Noise Level: <span id="noiseValue">0.1</span></label>
                                <input type="range" id="noiseLevel" min="0" max="1" step="0.05" value="0.1" class="w-full">
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-xl font-semibold mb-4">Analysis Parameters</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Window Type</label>
                                <select id="windowType" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="hann">Hann Window</option>
                                    <option value="hamming">Hamming Window</option>
                                    <option value="blackman">Blackman Window</option>
                                    <option value="rectangular">Rectangular</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">FFT Size: <span id="fftValue">1024</span></label>
                                <input type="range" id="fftSize" min="256" max="4096" step="256" value="1024" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Overlap (%): <span id="overlapValue">50</span></label>
                                <input type="range" id="overlap" min="0" max="90" step="10" value="50" class="w-full">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 xl:grid-cols-2 gap-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Time Domain Signal</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="timeDomainChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Power Spectral Density</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="psdChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="mt-8 p-4 bg-gray-50 rounded-lg">
                    <h4 class="font-semibold mb-2">Phase Coherence Analysis</h4>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
                        <div>Dominant Frequency: <span id="dominantFreq" class="font-mono">1.00 Hz</span></div>
                        <div>Phase Coherence: <span id="phaseCoherence" class="font-mono">0.95</span></div>
                        <div>Signal-to-Noise Ratio: <span id="snr" class="font-mono">15.2 dB</span></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Wavelet Analysis Section -->
        <section id="wavelet" class="mb-16">
            <div class="bg-white rounded-lg shadow-lg p-8">
                <h2 class="text-3xl font-bold text-bio-heading mb-4">🌊 Wavelet Analysis for Non-Stationary Signals</h2>
                <p class="text-bio-text mb-6">
                    Unlike Fourier analysis which assumes stationarity, wavelet transforms can localize spectral features in both time and frequency domains, making them ideal for analyzing transient biological phenomena like damping rhythms or burst events.
                </p>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Signal Parameters</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Wavelet Type</label>
                                <select id="waveletType" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="morlet">Morlet Wavelet</option>
                                    <option value="mexican">Mexican Hat</option>
                                    <option value="haar">Haar Wavelet</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Signal Type</label>
                                <select id="waveletSignalType" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="transient">Transient Event</option>
                                    <option value="chirp">Frequency Chirp</option>
                                    <option value="damping">Damping Oscillation</option>
                                    <option value="burst">Neural Burst</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Time Localization: <span id="timeLocValue">0.5</span></label>
                                <input type="range" id="timeLocalization" min="0.1" max="1.0" step="0.1" value="0.5" class="w-full">
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-xl font-semibold mb-4">Analysis Controls</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Frequency Resolution</label>
                                <input type="range" id="freqResolution" min="10" max="100" step="5" value="50" class="w-full">
                                <div class="text-xs text-gray-500 mt-1">Scales: <span id="scaleCount">50</span></div>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Color Scale</label>
                                <select id="colorScale" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="viridis">Viridis</option>
                                    <option value="plasma">Plasma</option>
                                    <option value="jet">Jet</option>
                                </select>
                            </div>
                            <button id="analyzeWavelet" class="bg-spectral-purple text-white px-4 py-2 rounded-md hover:bg-spectral-purple/80 transition-colors w-full">
                                Analyze Signal
                            </button>
                        </div>
                    </div>
                </div>

                <div class="space-y-6">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Time Domain Signal</h3>
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <canvas id="waveletTimeChart" class="w-full max-w-full" style="height: 200px;"></canvas>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-xl font-semibold mb-4">Time-Frequency Spectrogram</h3>
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <canvas id="waveletSpectrogram" class="w-full max-w-full" style="height: 250px;"></canvas>
                        </div>
                    </div>
                </div>

                <div class="mt-8 p-4 bg-gray-50 rounded-lg">
                    <h4 class="font-semibold mb-2">Wavelet Analysis Results</h4>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                        <div>Peak Frequency: <span id="peakFreq" class="font-mono">2.5 Hz</span></div>
                        <div>Time of Occurrence: <span id="eventTime" class="font-mono">1.2 s</span></div>
                        <div>Frequency Spread: <span id="freqSpread" class="font-mono">±0.8 Hz</span></div>
                        <div>Energy Concentration: <span id="energyConc" class="font-mono">78%</span></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- HOSA Section -->
        <section id="hosa" class="mb-16">
            <div class="bg-white rounded-lg shadow-lg p-8">
                <h2 class="text-3xl font-bold text-bio-heading mb-4">🔗 Higher-Order Spectral Analysis (HOSA)</h2>
                <p class="text-bio-text mb-6">
                    Higher-Order Spectral Analysis goes beyond the Power Spectral Density to detect quadratic phase coupling (QPC) between frequencies. The bispectrum and bicoherence reveal nonlinear interactions that standard Fourier analysis cannot detect.
                </p>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Coupled Signal Generation</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Primary Frequency (f₁): <span id="f1Value">10</span> Hz</label>
                                <input type="range" id="freq1" min="5" max="50" step="1" value="10" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Secondary Frequency (f₂): <span id="f2Value">15</span> Hz</label>
                                <input type="range" id="freq2" min="5" max="50" step="1" value="15" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Coupling Strength: <span id="couplingStrengthValue">0.3</span></label>
                                <input type="range" id="couplingStrength" min="0" max="1" step="0.05" value="0.3" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Phase Offset: <span id="phaseOffsetValue">0</span>°</label>
                                <input type="range" id="phaseOffset" min="0" max="360" step="15" value="0" class="w-full">
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-xl font-semibold mb-4">Analysis Method</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Analysis Type</label>
                                <select id="hosaType" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="bispectrum">Bispectrum</option>
                                    <option value="bicoherence">Bicoherence</option>
                                    <option value="cumulants">Cumulants</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Window Length: <span id="windowLengthValue">256</span></label>
                                <input type="range" id="windowLength" min="64" max="1024" step="64" value="256" class="w-full">
                            </div>
                            <div class="flex items-center space-x-2">
                                <input type="checkbox" id="showUncoupled" class="rounded">
                                <label for="showUncoupled" class="text-sm font-medium text-gray-700">Show Uncoupled Reference</label>
                            </div>
                            <button id="computeHOSA" class="bg-spectral-green text-white px-4 py-2 rounded-md hover:bg-spectral-green/80 transition-colors">
                                Compute HOSA
                            </button>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 xl:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Time Domain Signals</h3>
                        <div style="position: relative; height: 250px; width: 100%;">
                            <canvas id="hosaTimeChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Frequency Domain (PSD)</h3>
                        <div style="position: relative; height: 250px; width: 100%;">
                            <canvas id="hosaPSDChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 xl:grid-cols-2 gap-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Bispectrum Magnitude</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="bispectrumChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Bicoherence</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="bicoherenceChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="mt-8 p-4 bg-gray-50 rounded-lg">
                    <h4 class="font-semibold mb-2">HOSA Analysis Results</h4>
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4 text-sm">
                        <div>QPC Detected: <span id="qpcDetected" class="font-mono text-green-600">Yes</span></div>
                        <div>Bicoherence Peak: <span id="bicoherencePeak" class="font-mono">0.85</span></div>
                        <div>Coupling Frequency: <span id="couplingFreq" class="font-mono">25 Hz</span></div>
                        <div>Phase Coupling: <span id="phaseCoupling" class="font-mono">42°</span></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Additional sections would go here -->
        <section id="graphs" class="mb-16">
            <div class="bg-white rounded-lg shadow-lg p-8">
                <h2 class="text-3xl font-bold text-bio-heading mb-4">🕸️ Spectral Graph Theory in GRNs</h2>
                <p class="text-bio-text mb-6">
                    Spectral Graph Theory analyzes gene regulatory networks using eigenvalue decomposition of adjacency and Laplacian matrices. This reveals network connectivity patterns, prioritizes critical interactions, and provides robust analysis against molecular noise.
                </p>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Network Generation</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Network Type</label>
                                <select id="networkType" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="random">Random Network</option>
                                    <option value="scalefree">Scale-Free Network</option>
                                    <option value="smallworld">Small-World Network</option>
                                    <option value="modular">Modular Network</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Number of Genes: <span id="geneCountValue">20</span></label>
                                <input type="range" id="geneCount" min="10" max="50" step="5" value="20" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Connectivity: <span id="connectivityValue">0.3</span></label>
                                <input type="range" id="connectivity" min="0.1" max="0.8" step="0.05" value="0.3" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Noise Level: <span id="noiseLevelValue">0.1</span></label>
                                <input type="range" id="networkNoise" min="0" max="0.5" step="0.05" value="0.1" class="w-full">
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-xl font-semibold mb-4">Spectral Analysis</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Matrix Type</label>
                                <select id="matrixType" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="adjacency">Adjacency Matrix</option>
                                    <option value="laplacian">Laplacian Matrix</option>
                                    <option value="normalized">Normalized Laplacian</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Eigenvalue Range: <span id="eigenRangeValue">10</span></label>
                                <input type="range" id="eigenRange" min="5" max="20" step="1" value="10" class="w-full">
                            </div>
                            <div class="flex items-center space-x-2">
                                <input type="checkbox" id="showEigenvectors" class="rounded">
                                <label for="showEigenvectors" class="text-sm font-medium text-gray-700">Show Eigenvector Analysis</label>
                            </div>
                            <button id="analyzeNetwork" class="bg-spectral-purple text-white px-4 py-2 rounded-md hover:bg-spectral-purple/80 transition-colors w-full">
                                Analyze Network
                            </button>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 xl:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Network Visualization</h3>
                        <div style="position: relative; height: 350px; width: 100%;">
                            <canvas id="networkChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Eigenvalue Spectrum</h3>
                        <div style="position: relative; height: 350px; width: 100%;">
                            <canvas id="eigenvalueChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 xl:grid-cols-2 gap-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Adjacency Matrix</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="adjacencyChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Network Metrics</h3>
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <div class="grid grid-cols-2 gap-4 text-sm">
                                <div>Clustering Coefficient: <span id="clusteringCoeff" class="font-mono">0.00</span></div>
                                <div>Average Path Length: <span id="avgPathLength" class="font-mono">0.00</span></div>
                                <div>Spectral Gap: <span id="spectralGap" class="font-mono">0.00</span></div>
                                <div>Algebraic Connectivity: <span id="algebraicConn" class="font-mono">0.00</span></div>
                                <div>Network Diameter: <span id="networkDiameter" class="font-mono">0</span></div>
                                <div>Robustness Score: <span id="robustnessScore" class="font-mono">0.00</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Protein Folding Dynamics Section -->
        <section id="folding" class="mb-16">
            <div class="bg-white rounded-lg shadow-lg p-8">
                <h2 class="text-3xl font-bold text-bio-heading mb-4">🧬 Protein Folding Dynamics</h2>
                <p class="text-bio-text mb-6">
                    Protein folding is a complex process where linear amino acid sequences self-organize into functional 3D structures. Spectral analysis reveals the dynamical landscape of folding pathways, energy barriers, and conformational transitions that govern protein function and misfolding diseases.
                </p>

                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Folding Parameters</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Protein Model</label>
                                <select id="proteinModel" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="helix">α-Helix Bundle</option>
                                    <option value="sheet">β-Sheet Protein</option>
                                    <option value="mixed">Mixed Structure</option>
                                    <option value="disordered">Intrinsically Disordered</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Folding Scenario</label>
                                <select id="foldingScenario" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="native">Native Folding</option>
                                    <option value="misfold">Misfolding Pathway</option>
                                    <option value="aggregation">Aggregation Prone</option>
                                    <option value="chaperone">Chaperone Assisted</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Temperature: <span id="tempValue" class="font-mono">298 K</span></label>
                                <input type="range" id="foldingTemp" min="273" max="373" value="298" step="5" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Simulation Time: <span id="timeValue" class="font-mono">100 ns</span></label>
                                <input type="range" id="foldingTime" min="10" max="1000" value="100" step="10" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Energy Landscape Roughness: <span id="roughnessValue" class="font-mono">0.5</span></label>
                                <input type="range" id="landscapeRoughness" min="0.1" max="2.0" value="0.5" step="0.1" class="w-full">
                            </div>
                        </div>
                        <button id="simulateFolding" class="mt-4 w-full bg-spectral-purple text-white py-2 px-4 rounded-md hover:bg-spectral-purple/80 transition-colors">
                            Simulate Folding
                        </button>
                    </div>

                    <div>
                        <h3 class="text-xl font-semibold mb-4">Energy Landscape</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="energyLandscapeChart"></canvas>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-xl font-semibold mb-4">Folding Trajectory</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="foldingTrajectoryChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Conformational Dynamics</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="conformationalChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Spectral Analysis</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="foldingSpectralChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="mt-8 p-4 bg-gray-50 rounded-lg">
                    <h4 class="font-semibold mb-2">Folding Dynamics Metrics</h4>
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4 text-sm">
                        <div>Folding Time: <span id="foldingTimeMetric" class="font-mono">0.0 ns</span></div>
                        <div>Free Energy Barrier: <span id="freeEnergyBarrier" class="font-mono">0.0 kJ/mol</span></div>
                        <div>Conformational Entropy: <span id="conformationalEntropy" class="font-mono">0.0 kJ/mol·K</span></div>
                        <div>Stability Index: <span id="stabilityIndex" class="font-mono">0.0</span></div>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4 text-sm mt-2">
                        <div>Transition States: <span id="transitionStates" class="font-mono">0</span></div>
                        <div>Native Contacts: <span id="nativeContacts" class="font-mono">0%</span></div>
                        <div>RMS Fluctuation: <span id="rmsFluctuation" class="font-mono">0.0 Å</span></div>
                        <div>Folding Cooperativity: <span id="foldingCooperativity" class="font-mono">0.0</span></div>
                    </div>
                </div>
            </div>
        </section>

        <section id="circadian" class="mb-16">
            <div class="bg-white rounded-lg shadow-lg p-8">
                <h2 class="text-3xl font-bold text-bio-heading mb-4">⏰ Circadian Rhythm Analysis</h2>
                <p class="text-bio-text mb-6">
                    Circadian rhythms are biological oscillations with periods of approximately 24 hours. This interactive tool demonstrates spectral analysis of circadian signals, including period detection, phase coherence, and damping rhythm analysis using concepts from specialized tools like Rhythmidia.
                </p>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Circadian Signal Parameters</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Circadian Period (hours): <span id="periodValue">24.0</span></label>
                                <input type="range" id="circadianPeriod" min="20" max="28" step="0.5" value="24.0" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Amplitude Damping: <span id="dampingValue">0.1</span></label>
                                <input type="range" id="amplitudeDamping" min="0" max="0.5" step="0.05" value="0.1" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Phase Noise: <span id="phaseNoiseValue">0.2</span></label>
                                <input type="range" id="phaseNoise" min="0" max="1" step="0.05" value="0.2" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Observation Days: <span id="daysValue">7</span></label>
                                <input type="range" id="observationDays" min="3" max="14" step="1" value="7" class="w-full">
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-xl font-semibold mb-4">Analysis Method</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Analysis Type</label>
                                <select id="circadianAnalysisType" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="periodogram">Periodogram Analysis</option>
                                    <option value="wavelet">Wavelet Transform</option>
                                    <option value="autocorr">Autocorrelation</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Sampling Rate (samples/hour): <span id="samplingValue">4</span></label>
                                <input type="range" id="samplingRate" min="1" max="12" step="1" value="4" class="w-full">
                            </div>
                            <div class="flex items-center space-x-2">
                                <input type="checkbox" id="showDamping" class="rounded">
                                <label for="showDamping" class="text-sm font-medium text-gray-700">Show Damping Analysis</label>
                            </div>
                            <button id="analyzeCircadian" class="bg-bio-green text-white px-4 py-2 rounded-md hover:bg-bio-green/80 transition-colors w-full">
                                Analyze Circadian Rhythm
                            </button>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 xl:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Time Domain Signal</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="circadianTimeChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Periodogram Analysis</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="circadianPeriodogram"></canvas>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 xl:grid-cols-2 gap-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Phase Distribution</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="circadianPhaseChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Rhythm Metrics</h3>
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <div class="grid grid-cols-2 gap-4 text-sm">
                                <div>Detected Period: <span id="detectedPeriod" class="font-mono text-bio-green">24.0 h</span></div>
                                <div>Phase Coherence: <span id="phaseCoherence" class="font-mono">0.85</span></div>
                                <div>Amplitude Stability: <span id="amplitudeStability" class="font-mono">78%</span></div>
                                <div>Rhythm Strength: <span id="rhythmStrength" class="font-mono">0.92</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- DNA Transcription Dynamics Section -->
        <section id="transcription" class="mb-16">
            <div class="bg-white rounded-lg shadow-lg p-8">
                <h2 class="text-3xl font-bold text-bio-heading mb-4">🧬 DNA Transcription Dynamics</h2>
                <p class="text-bio-text mb-6">
                    DNA transcription involves the conversion of genetic information from DNA to RNA by RNA polymerase. Spectral analysis reveals the dynamical processes of initiation, elongation, pausing, and termination that regulate gene expression and cellular function.
                </p>

                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Transcription Parameters</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Gene Type</label>
                                <select id="geneType" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="housekeeping">Housekeeping Gene</option>
                                    <option value="regulated">Regulated Gene</option>
                                    <option value="stress">Stress Response Gene</option>
                                    <option value="developmental">Developmental Gene</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Promoter Strength</label>
                                <select id="promoterStrength" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="weak">Weak Promoter</option>
                                    <option value="medium">Medium Promoter</option>
                                    <option value="strong">Strong Promoter</option>
                                    <option value="constitutive">Constitutive Promoter</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">RNA Polymerase Speed: <span id="speedValue" class="font-mono">50 nt/s</span></label>
                                <input type="range" id="polymeraseSpeed" min="10" max="100" value="50" step="5" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Transcription Factor Concentration: <span id="tfValue" class="font-mono">1.0 μM</span></label>
                                <input type="range" id="tfConcentration" min="0.1" max="10.0" value="1.0" step="0.1" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Chromatin State: <span id="chromatinValue" class="font-mono">Open</span></label>
                                <input type="range" id="chromatinState" min="0" max="1" value="0.3" step="0.1" class="w-full">
                            </div>
                        </div>
                        <button id="simulateTranscription" class="mt-4 w-full bg-spectral-green text-white py-2 px-4 rounded-md hover:bg-spectral-green/80 transition-colors">
                            Simulate Transcription
                        </button>
                    </div>

                    <div>
                        <h3 class="text-xl font-semibold mb-4">Transcription Kinetics</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="transcriptionKineticsChart"></canvas>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-xl font-semibold mb-4">Gene Expression Profile</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="expressionProfileChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">RNA Polymerase Movement</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="polymeraseMovementChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Transcriptional Noise</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="transcriptionNoiseChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Promoter Occupancy</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="promoterOccupancyChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Spectral Analysis</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="transcriptionSpectralChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="mt-8 p-4 bg-gray-50 rounded-lg">
                    <h4 class="font-semibold mb-2">Transcription Dynamics Metrics</h4>
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4 text-sm">
                        <div>Initiation Rate: <span id="initiationRate" class="font-mono">0.0 s⁻¹</span></div>
                        <div>Elongation Speed: <span id="elongationSpeed" class="font-mono">0.0 nt/s</span></div>
                        <div>Transcription Burst Size: <span id="burstSize" class="font-mono">0.0</span></div>
                        <div>Burst Frequency: <span id="burstFrequency" class="font-mono">0.0 Hz</span></div>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4 text-sm mt-2">
                        <div>Pausing Frequency: <span id="pausingFrequency" class="font-mono">0.0</span></div>
                        <div>Termination Efficiency: <span id="terminationEfficiency" class="font-mono">0%</span></div>
                        <div>Expression Noise: <span id="expressionNoise" class="font-mono">0.0</span></div>
                        <div>Regulatory Strength: <span id="regulatoryStrength" class="font-mono">0.0</span></div>
                    </div>
                </div>
            </div>
        </section>

    </main>
    </div>

    <!-- Footer -->
    <footer class="bg-gray-800 text-white py-8">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="text-center">
                <p class="text-gray-400">Interactive Frequency Domain Analysis in Biology</p>
                <p class="text-sm text-gray-500 mt-2">Based on the comprehensive review "Spectral Dynamics in Systems Biology"</p>
            </div>
        </div>
    </footer>

    <script>
        // Global chart instances
        let timeDomainChart, psdChart, waveletTimeChart, waveletSpectrogram, hosaTimeChart, hosaPSDChart, bispectrumChart, bicoherenceChart, circadianTimeChart, circadianPeriodogram, circadianPhaseChart, networkChart, eigenvalueChart, adjacencyChart, energyLandscapeChart, foldingTrajectoryChart, conformationalChart, foldingSpectralChart, transcriptionKineticsChart, expressionProfileChart, polymeraseMovementChart, transcriptionNoiseChart, promoterOccupancyChart, transcriptionSpectralChart;

        // Initialize all charts and controls
        document.addEventListener('DOMContentLoaded', function() {
            initializeCharts();
            setupEventListeners();
            updatePSD(); // Initial render
        });

        // Debounce utility function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function initializeCharts() {
            // PSD Analysis Charts
            const timeCtx = document.getElementById('timeDomainChart').getContext('2d');
            timeDomainChart = new Chart(timeCtx, {
                type: 'line',
                data: { datasets: [{ label: 'Signal', data: [], borderColor: 'rgb(75, 192, 192)', tension: 0.1, pointRadius: 0 }] },
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Time (s)' } },
                        y: { title: { display: true, text: 'Amplitude' } }
                    },
                    elements: { point: { radius: 0 } }
                }
            });

            const psdCtx = document.getElementById('psdChart').getContext('2d');
            psdChart = new Chart(psdCtx, {
                type: 'line',
                data: { datasets: [{ label: 'PSD', data: [], borderColor: 'rgb(153, 102, 255)', tension: 0.1 }] },
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    scales: { 
                        x: { 
                            type: 'logarithmic',
                            min: 0.1,
                            max: 500,
                            title: { display: true, text: 'Frequency (Hz)' }
                        },
                        y: {
                            type: 'logarithmic',
                            min: 0.001,
                            max: 10,
                            title: { display: true, text: 'Power' }
                        }
                    }
                }
            });

            // Wavelet Charts
            const waveletTimeCtx = document.getElementById('waveletTimeChart').getContext('2d');
            waveletTimeChart = new Chart(waveletTimeCtx, {
                type: 'line',
                data: { datasets: [{ label: 'Signal', data: [], borderColor: 'rgb(255, 159, 64)' }] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Time (s)' } },
                        y: { title: { display: true, text: 'Amplitude' } }
                    }
                }
            });

            // HOSA Charts
            const hosaTimeCtx = document.getElementById('hosaTimeChart').getContext('2d');
            hosaTimeChart = new Chart(hosaTimeCtx, {
                type: 'line',
                data: {
                    datasets: [
                        { label: 'Signal 1', data: [], borderColor: 'rgb(255, 99, 132)', borderWidth: 1, pointRadius: 0 },
                        { label: 'Signal 2', data: [], borderColor: 'rgb(54, 162, 235)', borderWidth: 1, pointRadius: 0 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'top' }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Time (s)' },
                            ticks: { maxTicksLimit: 10 }
                        },
                        y: {
                            title: { display: true, text: 'Amplitude' },
                            min: -2,
                            max: 2
                        }
                    },
                    elements: {
                        point: { radius: 0 }
                    }
                }
            });

            const hosaPSDCtx = document.getElementById('hosaPSDChart').getContext('2d');
            hosaPSDChart = new Chart(hosaPSDCtx, {
                type: 'line',
                data: {
                    datasets: [
                        { label: 'PSD 1', data: [], borderColor: 'rgb(255, 99, 132)', borderWidth: 1, pointRadius: 0 },
                        { label: 'PSD 2', data: [], borderColor: 'rgb(54, 162, 235)', borderWidth: 1, pointRadius: 0 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'top' }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: { display: true, text: 'Frequency (Hz)' },
                            min: 0,
                            max: 100,
                            ticks: { maxTicksLimit: 10 }
                        },
                        y: {
                            type: 'logarithmic',
                            title: { display: true, text: 'Power' },
                            min: 0.001,
                            max: 10
                        }
                    },
                    elements: {
                        point: { radius: 0 }
                    }
                }
            });

            // Bispectrum Chart
            const bispectrumCtx = document.getElementById('bispectrumChart').getContext('2d');
            bispectrumChart = new Chart(bispectrumCtx, {
                type: 'bubble',
                data: {
                    datasets: [{
                        label: 'Bispectrum',
                        data: [],
                        backgroundColor: 'rgba(75, 192, 192, 0.6)',
                        borderColor: 'rgba(75, 192, 192, 1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Frequency f1 (Hz)' }, min: 0, max: 50 },
                        y: { title: { display: true, text: 'Frequency f2 (Hz)' }, min: 0, max: 50 }
                    }
                }
            });

            // Bicoherence Chart
            const bicoherenceCtx = document.getElementById('bicoherenceChart').getContext('2d');
            bicoherenceChart = new Chart(bicoherenceCtx, {
                type: 'bubble',
                data: {
                    datasets: [{
                        label: 'Bicoherence',
                        data: [],
                        backgroundColor: 'rgba(153, 102, 255, 0.6)',
                        borderColor: 'rgba(153, 102, 255, 1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Frequency f1 (Hz)' }, min: 0, max: 50 },
                        y: { title: { display: true, text: 'Frequency f2 (Hz)' }, min: 0, max: 50 }
                    }
                }
            });

            // Circadian Charts
            const circadianTimeCtx = document.getElementById('circadianTimeChart').getContext('2d');
            circadianTimeChart = new Chart(circadianTimeCtx, {
                type: 'line',
                data: { datasets: [{ label: 'Circadian Signal', data: [], borderColor: 'rgb(34, 197, 94)', tension: 0.1, pointRadius: 0 }] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Time (hours)' } },
                        y: { title: { display: true, text: 'Amplitude' } }
                    },
                    elements: { point: { radius: 0 } }
                }
            });

            const circadianPeriodogramCtx = document.getElementById('circadianPeriodogram').getContext('2d');
            circadianPeriodogram = new Chart(circadianPeriodogramCtx, {
                type: 'line',
                data: { datasets: [{ label: 'Periodogram', data: [], borderColor: 'rgb(168, 85, 247)', tension: 0.1 }] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Period (hours)' }, min: 20, max: 28 },
                        y: { title: { display: true, text: 'Power' } }
                    }
                }
            });

            const circadianPhaseCtx = document.getElementById('circadianPhaseChart').getContext('2d');
            circadianPhaseChart = new Chart(circadianPhaseCtx, {
                type: 'bar',
                data: {
                    labels: Array.from({length: 24}, (_, i) => `${i}:00`),
                    datasets: [{
                        label: 'Phase Distribution',
                        data: [],
                        backgroundColor: 'rgba(34, 197, 94, 0.6)',
                        borderColor: 'rgba(34, 197, 94, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Hour of Day' } },
                        y: { title: { display: true, text: 'Activity Level' } }
                    },
                    plugins: {
                        legend: { display: false }
                    }
                }
            });

            // Spectral Graph Theory Charts
            const networkCtx = document.getElementById('networkChart').getContext('2d');
            networkChart = new Chart(networkCtx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Gene Nodes',
                        data: [],
                        backgroundColor: 'rgba(139, 92, 246, 0.8)',
                        borderColor: 'rgba(139, 92, 246, 1)',
                        pointRadius: 8
                    }, {
                        label: 'Edges',
                        data: [],
                        type: 'line',
                        backgroundColor: 'rgba(156, 163, 175, 0.3)',
                        borderColor: 'rgba(156, 163, 175, 0.5)',
                        borderWidth: 1,
                        pointRadius: 0,
                        showLine: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { min: -1.2, max: 1.2, title: { display: true, text: 'X Position' } },
                        y: { min: -1.2, max: 1.2, title: { display: true, text: 'Y Position' } }
                    }
                }
            });

            const eigenvalueCtx = document.getElementById('eigenvalueChart').getContext('2d');
            eigenvalueChart = new Chart(eigenvalueCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Eigenvalues',
                        data: [],
                        backgroundColor: 'rgba(245, 101, 101, 0.8)',
                        borderColor: 'rgba(245, 101, 101, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Index' } },
                        y: { title: { display: true, text: 'Eigenvalue' } }
                    },
                    plugins: {
                        legend: { display: false }
                    }
                }
            });

            const adjacencyCtx = document.getElementById('adjacencyChart').getContext('2d');
            adjacencyChart = new Chart(adjacencyCtx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Matrix Entries',
                        data: [],
                        backgroundColor: 'rgba(34, 197, 94, 0.8)',
                        borderColor: 'rgba(34, 197, 94, 1)',
                        pointRadius: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Gene i' }, min: 0 },
                        y: { title: { display: true, text: 'Gene j' }, min: 0 }
                    }
                }
            });
        }

        // Protein Folding Charts
        const energyLandscapeCtx = document.getElementById('energyLandscapeChart').getContext('2d');
        energyLandscapeChart = new Chart(energyLandscapeCtx, {
            type: 'contour',
            data: {
                datasets: [{
                    label: 'Free Energy Landscape',
                    data: [],
                    backgroundColor: 'rgba(139, 92, 246, 0.8)',
                    borderColor: 'rgba(139, 92, 246, 1)',
                    pointRadius: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false }
                },
                scales: {
                    x: { title: { display: true, text: 'Reaction Coordinate 1' } },
                    y: { title: { display: true, text: 'Reaction Coordinate 2' } }
                }
            }
        });

        const foldingTrajectoryCtx = document.getElementById('foldingTrajectoryChart').getContext('2d');
        foldingTrajectoryChart = new Chart(foldingTrajectoryCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'RMSD from Native',
                    data: [],
                    borderColor: 'rgba(245, 101, 101, 1)',
                    backgroundColor: 'rgba(245, 101, 101, 0.1)',
                    fill: true,
                    tension: 0.4
                }, {
                    label: 'Native Contacts',
                    data: [],
                    borderColor: 'rgba(34, 197, 94, 1)',
                    backgroundColor: 'rgba(34, 197, 94, 0.1)',
                    fill: false,
                    tension: 0.4,
                    yAxisID: 'y1'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { title: { display: true, text: 'Time (ns)' } },
                    y: { title: { display: true, text: 'RMSD (Å)' } },
                    y1: {
                        position: 'right',
                        title: { display: true, text: 'Native Contacts (%)' },
                        min: 0,
                        max: 100
                    }
                }
            }
        });

        const conformationalCtx = document.getElementById('conformationalChart').getContext('2d');
        conformationalChart = new Chart(conformationalCtx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Conformations',
                    data: [],
                    backgroundColor: 'rgba(59, 130, 246, 0.6)',
                    borderColor: 'rgba(59, 130, 246, 1)',
                    pointRadius: 3
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false }
                },
                scales: {
                    x: { title: { display: true, text: 'PC1' } },
                    y: { title: { display: true, text: 'PC2' } }
                }
            }
        });

        const foldingSpectralCtx = document.getElementById('foldingSpectralChart').getContext('2d');
        foldingSpectralChart = new Chart(foldingSpectralCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Power Spectrum',
                    data: [],
                    borderColor: 'rgba(168, 85, 247, 1)',
                    backgroundColor: 'rgba(168, 85, 247, 0.1)',
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { title: { display: true, text: 'Frequency (Hz)' }, type: 'logarithmic' },
                    y: { title: { display: true, text: 'Power' }, type: 'logarithmic' }
                }
            }
        });

        // DNA Transcription Charts
        const transcriptionKineticsCtx = document.getElementById('transcriptionKineticsChart').getContext('2d');
        transcriptionKineticsChart = new Chart(transcriptionKineticsCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Initiation Events',
                    data: [],
                    borderColor: 'rgba(34, 197, 94, 1)',
                    backgroundColor: 'rgba(34, 197, 94, 0.1)',
                    fill: true,
                    tension: 0.4
                }, {
                    label: 'Active Polymerases',
                    data: [],
                    borderColor: 'rgba(59, 130, 246, 1)',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    fill: false,
                    tension: 0.4,
                    yAxisID: 'y1'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { title: { display: true, text: 'Time (s)' } },
                    y: { title: { display: true, text: 'Initiation Rate (s⁻¹)' } },
                    y1: {
                        position: 'right',
                        title: { display: true, text: 'Active Polymerases' },
                        min: 0
                    }
                }
            }
        });

        const expressionProfileCtx = document.getElementById('expressionProfileChart').getContext('2d');
        expressionProfileChart = new Chart(expressionProfileCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'mRNA Concentration',
                    data: [],
                    borderColor: 'rgba(245, 101, 101, 1)',
                    backgroundColor: 'rgba(245, 101, 101, 0.1)',
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { title: { display: true, text: 'Time (min)' } },
                    y: { title: { display: true, text: 'Concentration (nM)' } }
                }
            }
        });

        const polymeraseMovementCtx = document.getElementById('polymeraseMovementChart').getContext('2d');
        polymeraseMovementChart = new Chart(polymeraseMovementCtx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'RNA Polymerase Positions',
                    data: [],
                    backgroundColor: 'rgba(168, 85, 247, 0.8)',
                    borderColor: 'rgba(168, 85, 247, 1)',
                    pointRadius: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false }
                },
                scales: {
                    x: { title: { display: true, text: 'Gene Position (nt)' } },
                    y: { title: { display: true, text: 'Time (s)' } }
                }
            }
        });

        const transcriptionNoiseCtx = document.getElementById('transcriptionNoiseChart').getContext('2d');
        transcriptionNoiseChart = new Chart(transcriptionNoiseCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Transcription Bursts',
                    data: [],
                    borderColor: 'rgba(251, 146, 60, 1)',
                    backgroundColor: 'rgba(251, 146, 60, 0.1)',
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { title: { display: true, text: 'Time (min)' } },
                    y: { title: { display: true, text: 'Burst Intensity' } }
                }
            }
        });

        const promoterOccupancyCtx = document.getElementById('promoterOccupancyChart').getContext('2d');
        promoterOccupancyChart = new Chart(promoterOccupancyCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'TF Bound',
                    data: [],
                    borderColor: 'rgba(139, 69, 19, 1)',
                    backgroundColor: 'rgba(139, 69, 19, 0.1)',
                    fill: true,
                    tension: 0.4
                }, {
                    label: 'Pol II Bound',
                    data: [],
                    borderColor: 'rgba(34, 197, 94, 1)',
                    backgroundColor: 'rgba(34, 197, 94, 0.1)',
                    fill: false,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { title: { display: true, text: 'Time (s)' } },
                    y: { title: { display: true, text: 'Occupancy (%)' } }
                }
            }
        });

        const transcriptionSpectralCtx = document.getElementById('transcriptionSpectralChart').getContext('2d');
        transcriptionSpectralChart = new Chart(transcriptionSpectralCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Power Spectrum',
                    data: [],
                    borderColor: 'rgba(147, 51, 234, 1)',
                    backgroundColor: 'rgba(147, 51, 234, 0.1)',
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { title: { display: true, text: 'Frequency (Hz)' }, type: 'logarithmic' },
                    y: { title: { display: true, text: 'Power' }, type: 'logarithmic' }
                }
            }
        });

        function setupEventListeners() {
            // PSD controls - use debounced update for performance
            const debouncedUpdatePSD = debounce(updatePSD, 150);
            ['signalType', 'frequency', 'noiseLevel', 'windowType', 'fftSize', 'overlap'].forEach(id => {
                document.getElementById(id).addEventListener('input', debouncedUpdatePSD);
            });

            // Update display values (immediate, no debounce needed)
            document.getElementById('frequency').addEventListener('input', function() {
                document.getElementById('freqValue').textContent = this.value;
            });
            document.getElementById('noiseLevel').addEventListener('input', function() {
                document.getElementById('noiseValue').textContent = this.value;
            });
            document.getElementById('fftSize').addEventListener('input', function() {
                document.getElementById('fftValue').textContent = this.value;
            });
            document.getElementById('overlap').addEventListener('input', function() {
                document.getElementById('overlapValue').textContent = this.value;
            });

            // HOSA controls
            ['freq1', 'freq2', 'couplingStrength', 'phaseOffset', 'hosaType', 'windowLength'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateHOSA);
            });

            document.getElementById('computeHOSA').addEventListener('click', updateHOSA);

            // Update HOSA display values
            document.getElementById('freq1').addEventListener('input', function() {
                document.getElementById('f1Value').textContent = this.value;
            });
            document.getElementById('freq2').addEventListener('input', function() {
                document.getElementById('f2Value').textContent = this.value;
            });
            document.getElementById('couplingStrength').addEventListener('input', function() {
                document.getElementById('couplingStrengthValue').textContent = this.value;
            });
            document.getElementById('phaseOffset').addEventListener('input', function() {
                document.getElementById('phaseOffsetValue').textContent = this.value;
            });
            document.getElementById('windowLength').addEventListener('input', function() {
                document.getElementById('windowLengthValue').textContent = this.value;
            });

            // Circadian controls
            ['circadianPeriod', 'amplitudeDamping', 'phaseNoise', 'observationDays', 'samplingRate'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateCircadianDisplay);
            });

            document.getElementById('analyzeCircadian').addEventListener('click', analyzeCircadianRhythm);

            // Update circadian display values
            document.getElementById('circadianPeriod').addEventListener('input', function() {
                document.getElementById('periodValue').textContent = this.value;
            });
            document.getElementById('amplitudeDamping').addEventListener('input', function() {
                document.getElementById('dampingValue').textContent = this.value;
            });
            document.getElementById('phaseNoise').addEventListener('input', function() {
                document.getElementById('phaseNoiseValue').textContent = this.value;
            });
            document.getElementById('observationDays').addEventListener('input', function() {
                document.getElementById('daysValue').textContent = this.value;
            });
            document.getElementById('samplingRate').addEventListener('input', function() {
                document.getElementById('samplingValue').textContent = this.value;
            });

            // Spectral Graph Theory controls
            ['geneCount', 'connectivity', 'networkNoise', 'eigenRange'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateNetworkDisplay);
            });

            document.getElementById('analyzeNetwork').addEventListener('click', analyzeNetwork);

            // Update network display values
            document.getElementById('geneCount').addEventListener('input', function() {
                document.getElementById('geneCountValue').textContent = this.value;
            });
            document.getElementById('connectivity').addEventListener('input', function() {
                document.getElementById('connectivityValue').textContent = this.value;
            });
            document.getElementById('networkNoise').addEventListener('input', function() {
                document.getElementById('noiseLevelValue').textContent = this.value;
            });
            document.getElementById('eigenRange').addEventListener('input', function() {
                document.getElementById('eigenRangeValue').textContent = this.value;
            });

            // Protein Folding controls
            ['foldingTemp', 'foldingTime', 'landscapeRoughness'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateFoldingDisplay);
            });

            document.getElementById('simulateFolding').addEventListener('click', simulateProteinFolding);

            // Update folding display values
            document.getElementById('foldingTemp').addEventListener('input', function() {
                document.getElementById('tempValue').textContent = this.value + ' K';
            });
            document.getElementById('foldingTime').addEventListener('input', function() {
                document.getElementById('timeValue').textContent = this.value + ' ns';
            });
            document.getElementById('landscapeRoughness').addEventListener('input', function() {
                document.getElementById('roughnessValue').textContent = parseFloat(this.value).toFixed(1);
            });

            // DNA Transcription controls
            ['polymeraseSpeed', 'tfConcentration', 'chromatinState'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateTranscriptionDisplay);
            });

            document.getElementById('simulateTranscription').addEventListener('click', simulateTranscription);

            // Update transcription display values
            document.getElementById('polymeraseSpeed').addEventListener('input', function() {
                document.getElementById('speedValue').textContent = this.value + ' nt/s';
            });
            document.getElementById('tfConcentration').addEventListener('input', function() {
                document.getElementById('tfValue').textContent = parseFloat(this.value).toFixed(1) + ' μM';
            });
            document.getElementById('chromatinState').addEventListener('input', function() {
                const state = parseFloat(this.value);
                const stateText = state < 0.3 ? 'Open' : state < 0.7 ? 'Mixed' : 'Closed';
                document.getElementById('chromatinValue').textContent = stateText;
            });
        }

        function updatePSD() {
            const signalType = document.getElementById('signalType').value;
            const frequency = parseFloat(document.getElementById('frequency').value);
            const noiseLevel = parseFloat(document.getElementById('noiseLevel').value);
            const fftSize = parseInt(document.getElementById('fftSize').value);

            // Generate signal
            const sampleRate = 1000; // Hz
            const duration = 2; // seconds
            const numSamples = sampleRate * duration;
            const time = Array.from({length: numSamples}, (_, i) => i / sampleRate);

            let signal = [];
            for (let t of time) {
                let value = 0;
                switch (signalType) {
                    case 'sine':
                        value = Math.sin(2 * Math.PI * frequency * t);
                        break;
                    case 'square':
                        value = Math.sign(Math.sin(2 * Math.PI * frequency * t));
                        break;
                    case 'sawtooth':
                        value = 2 * (t * frequency - Math.floor(t * frequency + 0.5));
                        break;
                    case 'noise':
                        value = (Math.random() - 0.5) * 2;
                        break;
                    case 'biological':
                        value = Math.sin(2 * Math.PI * frequency * t) + 0.3 * Math.sin(2 * Math.PI * 2 * frequency * t);
                        break;
                }
                // Add noise
                value += noiseLevel * (Math.random() - 0.5) * 2;
                signal.push(value);
            }

            // Update time domain chart
            timeDomainChart.data.labels = time.filter((_, i) => i % 10 === 0); // Downsample for display
            timeDomainChart.data.datasets[0].data = signal.filter((_, i) => i % 10 === 0);
            timeDomainChart.update();

            // Compute PSD (simplified)
            const psd = computePSD(signal, fftSize, sampleRate);
            const freqs = Array.from({length: psd.length}, (_, i) => Math.max(0.1, i * sampleRate / fftSize)); // Avoid zero for log scale

            psdChart.data.labels = freqs;
            psdChart.data.datasets[0].data = psd;
            psdChart.update();

            // Update analysis results
            const maxIdx = psd.indexOf(Math.max(...psd));
            document.getElementById('dominantFreq').textContent = freqs[maxIdx].toFixed(2) + ' Hz';
            document.getElementById('phaseCoherence').textContent = '0.95'; // Placeholder
            document.getElementById('snr').textContent = '15.2 dB'; // Placeholder
        }

        function computePSD(signal, fftSize, sampleRate) {
            // Simplified PSD computation using autocorrelation method
            const psd = new Array(fftSize / 2).fill(0);

            // Simple periodogram
            for (let k = 1; k < fftSize / 2; k++) {
                let real = 0, imag = 0;
                for (let n = 0; n < Math.min(signal.length, fftSize); n++) {
                    const angle = -2 * Math.PI * k * n / fftSize;
                    real += signal[n] * Math.cos(angle);
                    imag += signal[n] * Math.sin(angle);
                }
                psd[k] = (real * real + imag * imag) / fftSize;
            }

            return psd;
        }

        function updateHOSA() {
            const f1 = parseFloat(document.getElementById('freq1').value);
            const f2 = parseFloat(document.getElementById('freq2').value);
            const coupling = parseFloat(document.getElementById('couplingStrength').value);
            const phaseOffset = parseFloat(document.getElementById('phaseOffset').value) * Math.PI / 180;

            const sampleRate = 1000;
            const duration = 1;
            const numSamples = sampleRate * duration;
            const time = Array.from({length: numSamples}, (_, i) => i / sampleRate);

            // Generate coupled signals
            let signal1 = [], signal2 = [];
            for (let t of time) {
                const s1 = Math.sin(2 * Math.PI * f1 * t);
                const s2 = Math.sin(2 * Math.PI * f2 * t + phaseOffset);

                // Add quadratic coupling
                const coupled_s1 = s1 + coupling * s1 * s2;
                const coupled_s2 = s2 + coupling * s1 * s2;

                signal1.push(coupled_s1);
                signal2.push(coupled_s2);
            }

            // Update time domain chart
            hosaTimeChart.data.labels = time.filter((_, i) => i % 10 === 0);
            hosaTimeChart.data.datasets[0].data = signal1.filter((_, i) => i % 10 === 0);
            hosaTimeChart.data.datasets[1].data = signal2.filter((_, i) => i % 10 === 0);
            hosaTimeChart.update();

            // Compute PSDs
            const psd1 = computePSD(signal1, 256, sampleRate);
            const psd2 = computePSD(signal2, 256, sampleRate);
            const freqs = Array.from({length: psd1.length}, (_, i) => i * sampleRate / 256);

            hosaPSDChart.data.labels = freqs;
            hosaPSDChart.data.datasets[0].data = psd1;
            hosaPSDChart.data.datasets[1].data = psd2;
            hosaPSDChart.update();

            // Update results
            document.getElementById('qpcDetected').textContent = coupling > 0.1 ? 'Yes' : 'No';
            document.getElementById('bicoherencePeak').textContent = (coupling * 0.8).toFixed(2);
            document.getElementById('couplingFreq').textContent = (f1 + f2) + ' Hz';
            document.getElementById('phaseCoupling').textContent = (phaseOffset * 180 / Math.PI).toFixed(0) + '°';

            // Generate bispectrum data (simplified for demo)
            const bispectrumData = [];
            const bicoherenceData = [];
            const numPoints = 20; // Reduced for performance

            for (let i = 0; i < numPoints; i++) {
                for (let j = 0; j < numPoints; j++) {
                    const f1_val = (i / numPoints) * 50;
                    const f2_val = (j / numPoints) * 50;

                    // Simplified bispectrum calculation
                    const bispectrum = coupling * Math.exp(-Math.abs(f1_val - f1) / 10) * Math.exp(-Math.abs(f2_val - f2) / 10);
                    const bicoherence = Math.min(1, bispectrum / (coupling + 0.1));

                    if (bispectrum > 0.05) {
                        bispectrumData.push({ x: f1_val, y: f2_val, r: Math.max(1, bispectrum * 10) });
                    }
                    if (bicoherence > 0.2) {
                        bicoherenceData.push({ x: f1_val, y: f2_val, r: Math.max(1, bicoherence * 10) });
                    }
                }
            }

            bispectrumChart.data.datasets[0].data = bispectrumData;
            bispectrumChart.update();

            bicoherenceChart.data.datasets[0].data = bicoherenceData;
            bicoherenceChart.update();
        }

        function updateCircadianDisplay() {
            // Update display values for circadian controls
            document.getElementById('periodValue').textContent = document.getElementById('circadianPeriod').value;
            document.getElementById('dampingValue').textContent = document.getElementById('amplitudeDamping').value;
            document.getElementById('phaseNoiseValue').textContent = document.getElementById('phaseNoise').value;
            document.getElementById('daysValue').textContent = document.getElementById('observationDays').value;
            document.getElementById('samplingValue').textContent = document.getElementById('samplingRate').value;
        }

        function analyzeCircadianRhythm() {
            const period = parseFloat(document.getElementById('circadianPeriod').value);
            const damping = parseFloat(document.getElementById('amplitudeDamping').value);
            const phaseNoise = parseFloat(document.getElementById('phaseNoise').value);
            const days = parseInt(document.getElementById('observationDays').value);
            const samplingRate = parseInt(document.getElementById('samplingRate').value);

            // Generate circadian signal
            const signal = generateCircadianSignal(period, damping, phaseNoise, days, samplingRate);
            const timeHours = Array.from({length: signal.length}, (_, i) => i / samplingRate);

            // Update time domain chart
            circadianTimeChart.data.labels = timeHours;
            circadianTimeChart.data.datasets[0].data = signal;
            circadianTimeChart.update();

            // Compute periodogram
            const periodogram = computeCircadianPeriodogram(signal, samplingRate);
            const periods = Array.from({length: periodogram.length}, (_, i) => 20 + i * 0.1);

            circadianPeriodogram.data.labels = periods;
            circadianPeriodogram.data.datasets[0].data = periodogram;
            circadianPeriodogram.update();

            // Analyze phase distribution
            const phases = analyzeCircadianPhases(signal, period, samplingRate);
            circadianPhaseChart.data.datasets[0].data = phases;
            circadianPhaseChart.update();

            // Update metrics
            const detectedPeriod = detectCircadianPeriod(periodogram, periods);
            const coherence = calculatePhaseCoherence(signal, period, samplingRate);
            const stability = calculateAmplitudeStability(signal);
            const strength = Math.max(...periodogram) / periodogram.reduce((a, b) => a + b, 0) * periodogram.length;

            document.getElementById('detectedPeriod').textContent = detectedPeriod.toFixed(1) + ' h';
            document.getElementById('phaseCoherence').textContent = coherence.toFixed(2);
            document.getElementById('amplitudeStability').textContent = (stability * 100).toFixed(0) + '%';
            document.getElementById('rhythmStrength').textContent = strength.toFixed(2);
        }

        function generateCircadianSignal(period, damping, phaseNoise, days, samplingRate) {
            const totalHours = days * 24;
            const numSamples = totalHours * samplingRate;
            const signal = [];

            for (let i = 0; i < numSamples; i++) {
                const time = i / samplingRate;
                const cycles = time / period;

                // Base circadian oscillation
                let amplitude = Math.exp(-damping * cycles); // Damping over cycles
                let phase = 2 * Math.PI * cycles + (Math.random() - 0.5) * phaseNoise * 2 * Math.PI;

                const value = amplitude * Math.sin(phase);
                signal.push(value);
            }

            return signal;
        }

        function computeCircadianPeriodogram(signal, samplingRate) {
            // Simple periodogram for circadian range (20-28 hours)
            const periods = [];
            for (let p = 20; p <= 28; p += 0.1) {
                periods.push(p);
            }

            const periodogram = periods.map(period => {
                const freq = 1 / period;
                let real = 0, imag = 0;

                for (let i = 0; i < signal.length; i++) {
                    const time = i / samplingRate;
                    const angle = -2 * Math.PI * freq * time;
                    real += signal[i] * Math.cos(angle);
                    imag += signal[i] * Math.sin(angle);
                }

                return (real * real + imag * imag) / signal.length;
            });

            return periodogram;
        }

        function analyzeCircadianPhases(signal, period, samplingRate) {
            // Analyze phase distribution over 24 hours
            const phases = new Array(24).fill(0);
            const freq = 1 / period;

            for (let i = 0; i < signal.length; i++) {
                const time = i / samplingRate;
                const phase = (freq * time * 24) % 24; // Phase in hours
                const bin = Math.floor(phase);
                if (bin >= 0 && bin < 24) {
                    phases[bin] += Math.abs(signal[i]);
                }
            }

            return phases;
        }

        function detectCircadianPeriod(periodogram, periods) {
            const maxIndex = periodogram.indexOf(Math.max(...periodogram));
            return periods[maxIndex];
        }

        function calculatePhaseCoherence(signal, period, samplingRate) {
            // Simplified phase coherence calculation
            const freq = 1 / period;
            let coherenceSum = 0;
            let count = 0;

            for (let i = 0; i < signal.length - samplingRate * period; i += samplingRate) {
                const phase1 = Math.atan2(
                    signal.slice(i, i + samplingRate).reduce((sum, val, idx) => sum + val * Math.sin(2 * Math.PI * freq * idx / samplingRate), 0),
                    signal.slice(i, i + samplingRate).reduce((sum, val, idx) => sum + val * Math.cos(2 * Math.PI * freq * idx / samplingRate), 0)
                );

                const phase2 = Math.atan2(
                    signal.slice(i + samplingRate * period, i + 2 * samplingRate * period).reduce((sum, val, idx) => sum + val * Math.sin(2 * Math.PI * freq * (idx + samplingRate * period) / samplingRate), 0),
                    signal.slice(i + samplingRate * period, i + 2 * samplingRate * period).reduce((sum, val, idx) => sum + val * Math.cos(2 * Math.PI * freq * (idx + samplingRate * period) / samplingRate), 0)
                );

                coherenceSum += Math.cos(phase1 - phase2);
                count++;
            }

            return count > 0 ? Math.abs(coherenceSum / count) : 0;
        }

        function calculateAmplitudeStability(signal) {
            // Calculate coefficient of variation of local maxima
            const peaks = [];
            for (let i = 1; i < signal.length - 1; i++) {
                if (signal[i] > signal[i-1] && signal[i] > signal[i+1] && signal[i] > 0) {
                    peaks.push(signal[i]);
                }
            }

            if (peaks.length < 2) return 0;

            const mean = peaks.reduce((a, b) => a + b, 0) / peaks.length;
            const variance = peaks.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / peaks.length;
            const cv = Math.sqrt(variance) / mean;

            return Math.max(0, 1 - cv); // Convert to stability score
        }

        // Initialize HOSA charts with default values
        updateHOSA();

        function updateNetworkDisplay() {
            // Update display values for network controls
            document.getElementById('geneCountValue').textContent = document.getElementById('geneCount').value;
            document.getElementById('connectivityValue').textContent = document.getElementById('connectivity').value;
            document.getElementById('noiseLevelValue').textContent = document.getElementById('networkNoise').value;
            document.getElementById('eigenRangeValue').textContent = document.getElementById('eigenRange').value;
        }

        function analyzeNetwork() {
            const networkType = document.getElementById('networkType').value;
            const geneCount = parseInt(document.getElementById('geneCount').value);
            const connectivity = parseFloat(document.getElementById('connectivity').value);
            const noiseLevel = parseFloat(document.getElementById('networkNoise').value);
            const matrixType = document.getElementById('matrixType').value;
            const eigenRange = parseInt(document.getElementById('eigenRange').value);

            // Generate network
            const network = generateNetwork(networkType, geneCount, connectivity, noiseLevel);

            // Compute spectral properties
            const spectralData = computeSpectralProperties(network, matrixType, eigenRange);

            // Update visualizations
            updateNetworkVisualization(network);
            updateEigenvalueVisualization(spectralData.eigenvalues, eigenRange);
            updateAdjacencyVisualization(network.adjacencyMatrix);

            // Update metrics
            updateNetworkMetrics(network, spectralData);
        }

        function generateNetwork(type, size, connectivity, noise) {
            const network = {
                nodes: [],
                edges: [],
                adjacencyMatrix: []
            };

            // Initialize adjacency matrix
            for (let i = 0; i < size; i++) {
                network.adjacencyMatrix[i] = new Array(size).fill(0);
            }

            // Generate node positions (circular layout)
            for (let i = 0; i < size; i++) {
                const angle = (2 * Math.PI * i) / size;
                const radius = 0.8;
                network.nodes.push({
                    id: i,
                    x: radius * Math.cos(angle) + (Math.random() - 0.5) * noise,
                    y: radius * Math.sin(angle) + (Math.random() - 0.5) * noise
                });
            }

            // Generate connections based on network type
            switch (type) {
                case 'random':
                    generateRandomNetwork(network, connectivity, noise);
                    break;
                case 'scalefree':
                    generateScaleFreeNetwork(network, connectivity, noise);
                    break;
                case 'smallworld':
                    generateSmallWorldNetwork(network, connectivity, noise);
                    break;
                case 'modular':
                    generateModularNetwork(network, connectivity, noise);
                    break;
            }

            return network;
        }

        function generateRandomNetwork(network, connectivity, noise) {
            const size = network.nodes.length;
            for (let i = 0; i < size; i++) {
                for (let j = i + 1; j < size; j++) {
                    if (Math.random() < connectivity) {
                        const weight = 1 + (Math.random() - 0.5) * noise;
                        network.adjacencyMatrix[i][j] = weight;
                        network.adjacencyMatrix[j][i] = weight;
                        network.edges.push({ source: i, target: j, weight: weight });
                    }
                }
            }
        }

        function generateScaleFreeNetwork(network, connectivity, noise) {
            const size = network.nodes.length;
            // Start with a small fully connected core
            const coreSize = Math.min(3, size);
            for (let i = 0; i < coreSize; i++) {
                for (let j = i + 1; j < coreSize; j++) {
                    network.adjacencyMatrix[i][j] = 1;
                    network.adjacencyMatrix[j][i] = 1;
                    network.edges.push({ source: i, target: j, weight: 1 });
                }
            }

            // Add remaining nodes with preferential attachment
            for (let i = coreSize; i < size; i++) {
                const degrees = network.adjacencyMatrix.map(row => row.reduce((sum, val) => sum + val, 0));
                const totalDegree = degrees.reduce((sum, deg) => sum + deg, 0);

                for (let j = 0; j < i; j++) {
                    const attachmentProb = degrees[j] / totalDegree;
                    if (Math.random() < attachmentProb * connectivity * 2) {
                        const weight = 1 + (Math.random() - 0.5) * noise;
                        network.adjacencyMatrix[i][j] = weight;
                        network.adjacencyMatrix[j][i] = weight;
                        network.edges.push({ source: i, target: j, weight: weight });
                    }
                }
            }
        }

        function generateSmallWorldNetwork(network, connectivity, noise) {
            const size = network.nodes.length;
            const k = Math.floor(connectivity * size / 2); // Average degree

            // Create regular ring lattice
            for (let i = 0; i < size; i++) {
                for (let j = 1; j <= k; j++) {
                    const neighbor = (i + j) % size;
                    const weight = 1 + (Math.random() - 0.5) * noise;
                    network.adjacencyMatrix[i][neighbor] = weight;
                    network.adjacencyMatrix[neighbor][i] = weight;
                    network.edges.push({ source: i, target: neighbor, weight: weight });
                }
            }

            // Add random rewiring (Watts-Strogatz model)
            for (let i = 0; i < size; i++) {
                for (let j = 1; j <= k; j++) {
                    if (Math.random() < 0.1) { // Rewiring probability
                        const neighbor = (i + j) % size;
                        network.adjacencyMatrix[i][neighbor] = 0;
                        network.adjacencyMatrix[neighbor][i] = 0;

                        // Find new random connection
                        let newNeighbor;
                        do {
                            newNeighbor = Math.floor(Math.random() * size);
                        } while (newNeighbor === i || network.adjacencyMatrix[i][newNeighbor] > 0);

                        const weight = 1 + (Math.random() - 0.5) * noise;
                        network.adjacencyMatrix[i][newNeighbor] = weight;
                        network.adjacencyMatrix[newNeighbor][i] = weight;
                        network.edges.push({ source: i, target: newNeighbor, weight: weight });
                    }
                }
            }
        }

        function generateModularNetwork(network, connectivity, noise) {
            const size = network.nodes.length;
            const modules = Math.max(2, Math.floor(size / 10)); // Number of modules
            const moduleSize = Math.floor(size / modules);

            for (let m = 0; m < modules; m++) {
                const startIdx = m * moduleSize;
                const endIdx = Math.min((m + 1) * moduleSize, size);

                // Dense connections within modules
                for (let i = startIdx; i < endIdx; i++) {
                    for (let j = i + 1; j < endIdx; j++) {
                        if (Math.random() < connectivity * 2) {
                            const weight = 1 + (Math.random() - 0.5) * noise;
                            network.adjacencyMatrix[i][j] = weight;
                            network.adjacencyMatrix[j][i] = weight;
                            network.edges.push({ source: i, target: j, weight: weight });
                        }
                    }
                }

                // Sparse connections between modules
                if (m < modules - 1) {
                    const nextStart = (m + 1) * moduleSize;
                    for (let i = startIdx; i < endIdx; i++) {
                        for (let j = nextStart; j < Math.min(nextStart + moduleSize, size); j++) {
                            if (Math.random() < connectivity * 0.1) {
                                const weight = 1 + (Math.random() - 0.5) * noise;
                                network.adjacencyMatrix[i][j] = weight;
                                network.adjacencyMatrix[j][i] = weight;
                                network.edges.push({ source: i, target: j, weight: weight });
                            }
                        }
                    }
                }
            }
        }

        function computeSpectralProperties(network, matrixType, eigenRange) {
            const size = network.adjacencyMatrix.length;
            let matrix = JSON.parse(JSON.stringify(network.adjacencyMatrix)); // Deep copy

            // Compute matrix type
            if (matrixType === 'laplacian') {
                // Degree matrix
                const degrees = matrix.map(row => row.reduce((sum, val) => sum + val, 0));
                const degreeMatrix = degrees.map(deg => new Array(size).fill(0));
                for (let i = 0; i < size; i++) {
                    degreeMatrix[i][i] = degrees[i];
                }

                // Laplacian = Degree - Adjacency
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        matrix[i][j] = degreeMatrix[i][j] - matrix[i][j];
                    }
                }
            } else if (matrixType === 'normalized') {
                // Normalized Laplacian
                const degrees = matrix.map(row => row.reduce((sum, val) => sum + val, 0));
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        if (i === j) {
                            matrix[i][j] = 1;
                        } else if (degrees[i] > 0 && degrees[j] > 0) {
                            matrix[i][j] = -matrix[i][j] / Math.sqrt(degrees[i] * degrees[j]);
                        }
                    }
                }
            }

            // Simplified eigenvalue computation (power iteration for largest eigenvalues)
            const eigenvalues = [];
            const eigenvectors = [];

            // For demonstration, compute a few eigenvalues using simplified method
            for (let k = 0; k < Math.min(eigenRange, size); k++) {
                const { eigenvalue, eigenvector } = powerIteration(matrix, k > 0 ? eigenvectors : null);
                eigenvalues.push(eigenvalue);
                eigenvectors.push(eigenvector);
            }

            return { eigenvalues, eigenvectors, matrix };
        }

        function powerIteration(matrix, previousVectors) {
            const size = matrix.length;
            let vector = new Array(size).fill(0);
            vector[0] = 1; // Initial guess

            // Deflate previous eigenvectors
            if (previousVectors) {
                for (const prevVector of previousVectors) {
                    const dotProduct = vector.reduce((sum, val, i) => sum + val * prevVector[i], 0);
                    for (let i = 0; i < size; i++) {
                        vector[i] -= dotProduct * prevVector[i];
                    }
                }
            }

            // Normalize
            const norm = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
            vector = vector.map(val => val / norm);

            // Power iteration
            for (let iter = 0; iter < 50; iter++) {
                // Matrix-vector multiplication
                const newVector = new Array(size).fill(0);
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        newVector[i] += matrix[i][j] * vector[j];
                    }
                }

                // Normalize
                const newNorm = Math.sqrt(newVector.reduce((sum, val) => sum + val * val, 0));
                vector = newVector.map(val => val / newNorm);
            }

            // Compute Rayleigh quotient for eigenvalue
            let eigenvalue = 0;
            const mv = new Array(size).fill(0);
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    mv[i] += matrix[i][j] * vector[j];
                }
            }
            eigenvalue = vector.reduce((sum, val, i) => sum + val * mv[i], 0);

            return { eigenvalue, eigenvector: vector };
        }

        function updateNetworkVisualization(network) {
            // Update node positions
            networkChart.data.datasets[0].data = network.nodes.map(node => ({
                x: node.x,
                y: node.y
            }));

            // Update edges
            const edgeData = [];
            network.edges.forEach(edge => {
                const source = network.nodes[edge.source];
                const target = network.nodes[edge.target];
                edgeData.push({ x: source.x, y: source.y });
                edgeData.push({ x: target.x, y: target.y });
                edgeData.push({ x: null, y: null }); // Break line
            });
            networkChart.data.datasets[1].data = edgeData;

            networkChart.update();
        }

        function updateEigenvalueVisualization(eigenvalues, range) {
            eigenvalueChart.data.labels = eigenvalues.slice(0, range).map((_, i) => `λ${i + 1}`);
            eigenvalueChart.data.datasets[0].data = eigenvalues.slice(0, range);
            eigenvalueChart.update();
        }

        function updateAdjacencyVisualization(adjacencyMatrix) {
            const data = [];
            const size = adjacencyMatrix.length;
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (adjacencyMatrix[i][j] > 0) {
                        data.push({ x: i, y: j });
                    }
                }
            }
            adjacencyChart.data.datasets[0].data = data;
            adjacencyChart.update();
        }

        function updateNetworkMetrics(network, spectralData) {
            const size = network.nodes.length;

            // Clustering coefficient
            let totalClustering = 0;
            for (let i = 0; i < size; i++) {
                const neighbors = [];
                for (let j = 0; j < size; j++) {
                    if (network.adjacencyMatrix[i][j] > 0) {
                        neighbors.push(j);
                    }
                }

                if (neighbors.length >= 2) {
                    let triangles = 0;
                    for (let k = 0; k < neighbors.length; k++) {
                        for (let l = k + 1; l < neighbors.length; l++) {
                            if (network.adjacencyMatrix[neighbors[k]][neighbors[l]] > 0) {
                                triangles++;
                            }
                        }
                    }
                    const possibleTriangles = neighbors.length * (neighbors.length - 1) / 2;
                    totalClustering += possibleTriangles > 0 ? triangles / possibleTriangles : 0;
                }
            }
            const clusteringCoeff = size > 0 ? totalClustering / size : 0;

            // Average path length (simplified)
            const avgPathLength = Math.log(size) / Math.log(2); // Approximation

            // Spectral gap
            const spectralGap = spectralData.eigenvalues.length >= 2 ?
                spectralData.eigenvalues[1] - spectralData.eigenvalues[0] : 0;

            // Algebraic connectivity (second smallest eigenvalue of Laplacian)
            const algebraicConn = spectralData.eigenvalues.length >= 2 ?
                spectralData.eigenvalues[1] : 0;

            // Network diameter (simplified)
            const networkDiameter = Math.ceil(Math.log2(size));

            // Robustness score (based on spectral gap and connectivity)
            const robustnessScore = (spectralGap + algebraicConn) / 2;

            // Update display
            document.getElementById('clusteringCoeff').textContent = clusteringCoeff.toFixed(3);
            document.getElementById('avgPathLength').textContent = avgPathLength.toFixed(2);
            document.getElementById('spectralGap').textContent = spectralGap.toFixed(3);
            document.getElementById('algebraicConn').textContent = algebraicConn.toFixed(3);
            document.getElementById('networkDiameter').textContent = networkDiameter;
            document.getElementById('robustnessScore').textContent = robustnessScore.toFixed(3);
        }

        function updateFoldingDisplay() {
            // Update display values for folding controls
            document.getElementById('tempValue').textContent = document.getElementById('foldingTemp').value + ' K';
            document.getElementById('timeValue').textContent = document.getElementById('foldingTime').value + ' ns';
            document.getElementById('roughnessValue').textContent = parseFloat(document.getElementById('landscapeRoughness').value).toFixed(1);
        }

        function simulateProteinFolding() {
            const proteinModel = document.getElementById('proteinModel').value;
            const foldingScenario = document.getElementById('foldingScenario').value;
            const temperature = parseFloat(document.getElementById('foldingTemp').value);
            const simulationTime = parseFloat(document.getElementById('foldingTime').value);
            const roughness = parseFloat(document.getElementById('landscapeRoughness').value);

            // Generate folding simulation data
            const foldingData = generateFoldingSimulation(proteinModel, foldingScenario, temperature, simulationTime, roughness);

            // Update visualizations
            updateEnergyLandscape(foldingData.energyLandscape);
            updateFoldingTrajectory(foldingData.trajectory);
            updateConformationalDynamics(foldingData.conformations);
            updateFoldingSpectralAnalysis(foldingData.trajectory);

            // Update metrics
            updateFoldingMetrics(foldingData);
        }

        function generateFoldingSimulation(model, scenario, temp, time, roughness) {
            const timeSteps = Math.floor(time / 0.1); // 0.1 ns steps
            const trajectory = [];
            const conformations = [];
            let currentEnergy = 100; // Initial unfolded state energy
            let nativeContacts = 0;
            let rmsd = 5.0; // Initial RMSD from native structure

            // Energy landscape parameters based on model
            const landscapeParams = getLandscapeParameters(model, scenario);

            // Generate folding trajectory
            for (let t = 0; t < timeSteps; t++) {
                const timePoint = t * 0.1;

                // Simulate energy changes based on folding scenario
                const energyChange = simulateEnergyDynamics(currentEnergy, temp, roughness, landscapeParams, scenario);
                currentEnergy += energyChange;

                // Update structural properties
                const structuralChange = simulateStructuralDynamics(rmsd, nativeContacts, energyChange, landscapeParams);
                rmsd = Math.max(0, rmsd + structuralChange.rmsdChange);
                nativeContacts = Math.min(100, Math.max(0, nativeContacts + structuralChange.contactChange));

                trajectory.push({
                    time: timePoint,
                    energy: currentEnergy,
                    rmsd: rmsd,
                    nativeContacts: nativeContacts
                });

                // Sample conformations for PCA
                if (t % 10 === 0) { // Sample every 1 ns
                    conformations.push({
                        pc1: Math.random() * 10 - 5 + (1 - nativeContacts/100) * 3,
                        pc2: Math.random() * 10 - 5 + (1 - nativeContacts/100) * 3,
                        energy: currentEnergy
                    });
                }
            }

            // Generate energy landscape
            const energyLandscape = generateEnergyLandscape(landscapeParams, roughness);

            return {
                trajectory,
                conformations,
                energyLandscape,
                finalEnergy: currentEnergy,
                finalRMSD: rmsd,
                finalContacts: nativeContacts
            };
        }

        function getLandscapeParameters(model, scenario) {
            const baseParams = {
                helix: { barrier: 50, wells: 2, roughness: 0.3 },
                sheet: { barrier: 75, wells: 3, roughness: 0.5 },
                mixed: { barrier: 60, wells: 4, roughness: 0.4 },
                disordered: { barrier: 25, wells: 1, roughness: 0.2 }
            };

            const scenarioMods = {
                native: { barrierMult: 1.0, misfoldProb: 0.1 },
                misfold: { barrierMult: 1.2, misfoldProb: 0.4 },
                aggregation: { barrierMult: 1.5, misfoldProb: 0.6 },
                chaperone: { barrierMult: 0.7, misfoldProb: 0.05 }
            };

            const params = baseParams[model];
            const mods = scenarioMods[scenario];

            return {
                barrier: params.barrier * mods.barrierMult,
                wells: params.wells,
                roughness: params.roughness,
                misfoldProb: mods.misfoldProb
            };
        }

        function simulateEnergyDynamics(currentEnergy, temp, roughness, params, scenario) {
            // Langevin dynamics simulation
            const kT = 0.008314 * temp; // kT in kJ/mol
            const friction = 0.1;
            const dt = 0.1;

            // Force from energy landscape gradient
            const gradient = (Math.random() - 0.5) * roughness * 10;

            // Random force (thermal noise)
            const randomForce = (Math.random() - 0.5) * Math.sqrt(2 * kT * friction / dt);

            // Misfolding bias
            const misfoldBias = scenario === 'misfold' || scenario === 'aggregation' ?
                (Math.random() < params.misfoldProb ? 5 : 0) : 0;

            return -gradient * dt / friction + randomForce * dt / friction + misfoldBias;
        }

        function simulateStructuralDynamics(rmsd, contacts, energyChange, params) {
            // Structural changes coupled to energy
            const energyDriving = -energyChange * 0.1; // Energy decrease drives folding

            // Contact formation probability
            const contactProb = Math.max(0, Math.min(1, (100 - rmsd) / 100));

            const contactChange = energyDriving > 0 && Math.random() < contactProb ?
                Math.random() * 5 : (Math.random() - 0.7) * 2;

            const rmsdChange = energyDriving * 0.2 + (Math.random() - 0.5) * 0.1;

            return { rmsdChange, contactChange };
        }

        function generateEnergyLandscape(params, roughness) {
            const landscape = [];
            const gridSize = 20;

            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const x = (i / gridSize) * 10 - 5;
                    const y = (j / gridSize) * 10 - 5;

                    // Multi-well potential with barriers
                    let energy = 0;
                    for (let w = 0; w < params.wells; w++) {
                        const wx = Math.cos(w * Math.PI * 2 / params.wells) * 3;
                        const wy = Math.sin(w * Math.PI * 2 / params.wells) * 3;
                        const wellDepth = -30 - Math.random() * 20;
                        const dist = Math.sqrt((x - wx) ** 2 + (y - wy) ** 2);
                        energy += wellDepth * Math.exp(-dist * dist / 2);
                    }

                    // Add barriers between wells
                    energy += params.barrier * Math.exp(-((x ** 2 + y ** 2) ** 0.5) / 2);

                    // Add roughness
                    energy += roughness * (Math.random() - 0.5) * 20;

                    landscape.push({ x, y, energy });
                }
            }

            return landscape;
        }

        function updateEnergyLandscape(landscape) {
            energyLandscapeChart.data.datasets[0].data = landscape.map(point => ({
                x: point.x,
                y: point.y,
                z: point.energy
            }));
            energyLandscapeChart.update();
        }

        function updateFoldingTrajectory(trajectory) {
            foldingTrajectoryChart.data.labels = trajectory.map(point => point.time.toFixed(1));
            foldingTrajectoryChart.data.datasets[0].data = trajectory.map(point => point.rmsd);
            foldingTrajectoryChart.data.datasets[1].data = trajectory.map(point => point.nativeContacts);
            foldingTrajectoryChart.update();
        }

        function updateConformationalDynamics(conformations) {
            conformationalChart.data.datasets[0].data = conformations.map(conf => ({
                x: conf.pc1,
                y: conf.pc2
            }));
            conformationalChart.update();
        }

        function updateFoldingSpectralAnalysis(trajectory) {
            // Compute power spectrum of RMSD fluctuations
            const rmsdData = trajectory.map(point => point.rmsd);
            const spectrum = computePowerSpectrum(rmsdData, 100); // 100 Hz sampling

            foldingSpectralChart.data.labels = spectrum.frequencies.map(f => f.toFixed(2));
            foldingSpectralChart.data.datasets[0].data = spectrum.power;
            foldingSpectralChart.update();
        }

        function computePowerSpectrum(data, sampleRate) {
            const n = data.length;
            const frequencies = [];
            const power = [];

            // Simple FFT approximation using autocorrelation
            for (let k = 1; k < n / 2; k++) {
                const freq = k * sampleRate / n;
                let real = 0, imag = 0;

                for (let i = 0; i < n; i++) {
                    const angle = -2 * Math.PI * k * i / n;
                    real += data[i] * Math.cos(angle);
                    imag += data[i] * Math.sin(angle);
                }

                const magnitude = Math.sqrt(real * real + imag * imag) / n;
                frequencies.push(freq);
                power.push(magnitude * magnitude);
            }

            return { frequencies, power };
        }

        function updateFoldingMetrics(data) {
            const trajectory = data.trajectory;
            const finalPoint = trajectory[trajectory.length - 1];

            // Folding time (time to reach 80% native contacts)
            const foldingTimeIndex = trajectory.findIndex(point => point.nativeContacts >= 80);
            const foldingTime = foldingTimeIndex >= 0 ? trajectory[foldingTimeIndex].time : trajectory[trajectory.length - 1].time;

            // Free energy barrier (simplified from energy landscape)
            const maxEnergy = Math.max(...trajectory.map(p => p.energy));
            const minEnergy = Math.min(...trajectory.map(p => p.energy));
            const freeEnergyBarrier = maxEnergy - minEnergy;

            // Conformational entropy (approximated from trajectory spread)
            const rmsdVariance = trajectory.reduce((sum, p) => sum + p.rmsd * p.rmsd, 0) / trajectory.length;
            const conformationalEntropy = 0.008314 * Math.log(Math.sqrt(rmsdVariance)); // kT * ln(σ)

            // Stability index (ratio of native to unfolded energy)
            const stabilityIndex = -minEnergy / 100; // Normalized to initial energy

            // Transition states (local maxima in energy)
            let transitionStates = 0;
            for (let i = 1; i < trajectory.length - 1; i++) {
                if (trajectory[i].energy > trajectory[i-1].energy && trajectory[i].energy > trajectory[i+1].energy) {
                    transitionStates++;
                }
            }

            // RMS fluctuation
            const rmsFluctuation = Math.sqrt(rmsdVariance);

            // Folding cooperativity (sharpness of transition)
            const cooperativity = trajectory.length > 0 ?
                1 / (1 + Math.exp(-(finalPoint.nativeContacts - 50) / 10)) : 0;

            // Update display
            document.getElementById('foldingTimeMetric').textContent = foldingTime.toFixed(1) + ' ns';
            document.getElementById('freeEnergyBarrier').textContent = freeEnergyBarrier.toFixed(1) + ' kJ/mol';
            document.getElementById('conformationalEntropy').textContent = conformationalEntropy.toFixed(2) + ' kJ/mol·K';
            document.getElementById('stabilityIndex').textContent = stabilityIndex.toFixed(2);
            document.getElementById('transitionStates').textContent = transitionStates;
            document.getElementById('nativeContacts').textContent = finalPoint.nativeContacts.toFixed(1) + '%';
            document.getElementById('rmsFluctuation').textContent = rmsFluctuation.toFixed(2) + ' Å';
            document.getElementById('foldingCooperativity').textContent = cooperativity.toFixed(2);
        }

        function updateTranscriptionDisplay() {
            // Update display values for transcription controls
            document.getElementById('speedValue').textContent = document.getElementById('polymeraseSpeed').value + ' nt/s';
            document.getElementById('tfValue').textContent = parseFloat(document.getElementById('tfConcentration').value).toFixed(1) + ' μM';
            const chromatinState = parseFloat(document.getElementById('chromatinState').value);
            const stateText = chromatinState < 0.3 ? 'Open' : chromatinState < 0.7 ? 'Mixed' : 'Closed';
            document.getElementById('chromatinValue').textContent = stateText;
        }

        function simulateTranscription() {
            const geneType = document.getElementById('geneType').value;
            const promoterStrength = document.getElementById('promoterStrength').value;
            const polymeraseSpeed = parseFloat(document.getElementById('polymeraseSpeed').value);
            const tfConcentration = parseFloat(document.getElementById('tfConcentration').value);
            const chromatinState = parseFloat(document.getElementById('chromatinState').value);

            // Generate transcription simulation data
            const transcriptionData = generateTranscriptionSimulation(geneType, promoterStrength, polymeraseSpeed, tfConcentration, chromatinState);

            // Update visualizations
            updateTranscriptionKinetics(transcriptionData.kinetics);
            updateExpressionProfile(transcriptionData.expression);
            updatePolymeraseMovement(transcriptionData.polymerases);
            updateTranscriptionNoise(transcriptionData.bursts);
            updatePromoterOccupancy(transcriptionData.occupancy);
            updateTranscriptionSpectralAnalysis(transcriptionData.expression);

            // Update metrics
            updateTranscriptionMetrics(transcriptionData);
        }

        function generateTranscriptionSimulation(geneType, promoterStrength, speed, tfConc, chromatin) {
            const simulationTime = 3600; // 1 hour in seconds
            const timeStep = 1; // 1 second steps
            const timePoints = simulationTime / timeStep;

            // Gene parameters based on type
            const geneParams = getGeneParameters(geneType, promoterStrength);

            // Initialize simulation state
            let activePolymerases = [];
            let mrnaConcentration = 0;
            const kinetics = { time: [], initiation: [], activePol: [] };
            const expression = { time: [], concentration: [] };
            const polymerases = [];
            const bursts = { time: [], intensity: [] };
            const occupancy = { time: [], tfBound: [], polIIBound: [] };

            // Promoter state
            let tfBound = 0;
            let polIIBound = 0;

            for (let t = 0; t < timePoints; t++) {
                const currentTime = t * timeStep;

                // Update promoter occupancy
                tfBound = updateTFBinding(tfBound, tfConc, geneParams.tfAffinity, timeStep);
                polIIBound = updatePolIIBinding(polIIBound, tfBound, chromatin, geneParams.polIIAffinity, timeStep);

                // Transcription initiation
                const initiationRate = polIIBound * geneParams.initiationRate * (1 - chromatin * 0.8);
                const newInitiations = Math.random() < initiationRate * timeStep ? 1 : 0;

                if (newInitiations > 0) {
                    // Add new polymerase
                    activePolymerases.push({
                        position: 0,
                        startTime: currentTime,
                        speed: speed * (1 - chromatin * 0.5) * (0.8 + Math.random() * 0.4)
                    });
                }

                // Update polymerase positions
                activePolymerases = activePolymerases.filter(pol => {
                    pol.position += pol.speed * timeStep;

                    // Check for pausing sites
                    if (Math.random() < geneParams.pauseProbability) {
                        pol.speed *= 0.1; // Pause
                        setTimeout(() => pol.speed = speed, 1000); // Resume after 1 second
                    }

                    // Termination
                    if (pol.position >= geneParams.geneLength) {
                        mrnaConcentration += 1; // Add completed mRNA
                        return false; // Remove polymerase
                    }
                    return true;
                });

                // Update mRNA concentration (with degradation)
                const degradationRate = geneParams.halfLife > 0 ? Math.log(2) / geneParams.halfLife : 0;
                mrnaConcentration *= Math.exp(-degradationRate * timeStep);

                // Record data
                kinetics.time.push(currentTime);
                kinetics.initiation.push(initiationRate);
                kinetics.activePol.push(activePolymerases.length);

                expression.time.push(currentTime / 60); // Convert to minutes
                expression.concentration.push(mrnaConcentration);

                occupancy.time.push(currentTime);
                occupancy.tfBound.push(tfBound * 100);
                occupancy.polIIBound.push(polIIBound * 100);

                // Record polymerase positions
                activePolymerases.forEach(pol => {
                    polymerases.push({
                        x: pol.position,
                        y: currentTime
                    });
                });

                // Detect bursts (sudden increases in initiation)
                if (t > 0 && initiationRate > kinetics.initiation[t-1] * 2) {
                    bursts.time.push(currentTime / 60);
                    bursts.intensity.push(initiationRate * 10);
                }
            }

            return {
                kinetics,
                expression,
                polymerases,
                bursts,
                occupancy,
                finalMetrics: {
                    avgInitiationRate: kinetics.initiation.reduce((a,b) => a+b, 0) / kinetics.initiation.length,
                    maxActivePol: Math.max(...kinetics.activePol),
                    avgExpression: expression.concentration.reduce((a,b) => a+b, 0) / expression.concentration.length,
                    burstCount: bursts.time.length
                }
            };
        }

        function getGeneParameters(geneType, promoterStrength) {
            const baseParams = {
                housekeeping: { initiationRate: 0.01, halfLife: 3600, pauseProb: 0.001, geneLength: 2000 },
                regulated: { initiationRate: 0.005, halfLife: 1800, pauseProb: 0.005, geneLength: 1500 },
                stress: { initiationRate: 0.002, halfLife: 900, pauseProb: 0.01, geneLength: 1000 },
                developmental: { initiationRate: 0.001, halfLife: 7200, pauseProb: 0.002, geneLength: 3000 }
            };

            const strengthMods = {
                weak: { rateMult: 0.3, affinityMult: 0.5 },
                medium: { rateMult: 1.0, affinityMult: 1.0 },
                strong: { rateMult: 3.0, affinityMult: 2.0 },
                constitutive: { rateMult: 5.0, affinityMult: 3.0 }
            };

            const params = baseParams[geneType];
            const mods = strengthMods[promoterStrength];

            return {
                initiationRate: params.initiationRate * mods.rateMult,
                halfLife: params.halfLife,
                pauseProbability: params.pauseProb,
                geneLength: params.geneLength,
                tfAffinity: 0.1 * mods.affinityMult,
                polIIAffinity: 0.05 * mods.affinityMult
            };
        }

        function updateTFBinding(currentBound, concentration, affinity, dt) {
            // Simple binding kinetics: d[bound]/dt = k_on * [free] * [TF] - k_off * [bound]
            const k_on = affinity * concentration;
            const k_off = 0.1; // dissociation rate
            const freeSites = 1 - currentBound;

            const dBound = (k_on * freeSites - k_off * currentBound) * dt;
            return Math.max(0, Math.min(1, currentBound + dBound));
        }

        function updatePolIIBinding(currentBound, tfBound, chromatin, affinity, dt) {
            // Pol II binding depends on TF occupancy and chromatin state
            const effectiveAffinity = affinity * (0.5 + 0.5 * tfBound) * (1 - chromatin * 0.7);
            const k_on = effectiveAffinity;
            const k_off = 0.2;
            const freeSites = 1 - currentBound;

            const dBound = (k_on * freeSites - k_off * currentBound) * dt;
            return Math.max(0, Math.min(1, currentBound + dBound));
        }

        function updateTranscriptionKinetics(kinetics) {
            transcriptionKineticsChart.data.labels = kinetics.time.map(t => (t / 60).toFixed(1)); // Convert to minutes
            transcriptionKineticsChart.data.datasets[0].data = kinetics.initiation;
            transcriptionKineticsChart.data.datasets[1].data = kinetics.activePol;
            transcriptionKineticsChart.update();
        }

        function updateExpressionProfile(expression) {
            expressionProfileChart.data.labels = expression.time.map(t => t.toFixed(1));
            expressionProfileChart.data.datasets[0].data = expression.concentration;
            expressionProfileChart.update();
        }

        function updatePolymeraseMovement(polymerases) {
            polymeraseMovementChart.data.datasets[0].data = polymerases.slice(-500); // Show last 500 points for performance
            polymeraseMovementChart.update();
        }

        function updateTranscriptionNoise(bursts) {
            transcriptionNoiseChart.data.labels = bursts.time.map(t => t.toFixed(1));
            transcriptionNoiseChart.data.datasets[0].data = bursts.intensity;
            transcriptionNoiseChart.update();
        }

        function updatePromoterOccupancy(occupancy) {
            promoterOccupancyChart.data.labels = occupancy.time.map(t => (t / 60).toFixed(1)); // Convert to minutes
            promoterOccupancyChart.data.datasets[0].data = occupancy.tfBound;
            promoterOccupancyChart.data.datasets[1].data = occupancy.polIIBound;
            promoterOccupancyChart.update();
        }

        function updateTranscriptionSpectralAnalysis(expression) {
            // Compute power spectrum of expression time series
            const expressionData = expression.concentration;
            const spectrum = computePowerSpectrum(expressionData, 1/60); // 1 sample per minute

            transcriptionSpectralChart.data.labels = spectrum.frequencies.map(f => f.toFixed(4));
            transcriptionSpectralChart.data.datasets[0].data = spectrum.power;
            transcriptionSpectralChart.update();
        }

        function updateTranscriptionMetrics(data) {
            const metrics = data.finalMetrics;
            const kinetics = data.kinetics;
            const expression = data.expression;

            // Calculate additional metrics
            const initiationRate = metrics.avgInitiationRate;
            const elongationSpeed = parseFloat(document.getElementById('polymeraseSpeed').value);
            const burstSize = metrics.maxActivePol;
            const burstFrequency = metrics.burstCount / (kinetics.time.length / 3600); // bursts per hour

            // Pausing frequency (simplified)
            const pausingFrequency = 0.01; // Placeholder

            // Termination efficiency (fraction that complete transcription)
            const terminationEfficiency = 85 + Math.random() * 10; // 85-95%

            // Expression noise (coefficient of variation)
            const expressionMean = metrics.avgExpression;
            const expressionVariance = expression.concentration.reduce((sum, val) => sum + Math.pow(val - expressionMean, 2), 0) / expression.concentration.length;
            const expressionNoise = expressionMean > 0 ? Math.sqrt(expressionVariance) / expressionMean : 0;

            // Regulatory strength (based on TF concentration effect)
            const regulatoryStrength = parseFloat(document.getElementById('tfConcentration').value) * 0.1;

            // Update display
            document.getElementById('initiationRate').textContent = initiationRate.toFixed(3) + ' s⁻¹';
            document.getElementById('elongationSpeed').textContent = elongationSpeed.toFixed(0) + ' nt/s';
            document.getElementById('burstSize').textContent = burstSize.toFixed(1);
            document.getElementById('burstFrequency').textContent = burstFrequency.toFixed(2) + ' h⁻¹';
            document.getElementById('pausingFrequency').textContent = pausingFrequency.toFixed(3);
            document.getElementById('terminationEfficiency').textContent = terminationEfficiency.toFixed(1) + '%';
            document.getElementById('expressionNoise').textContent = expressionNoise.toFixed(3);
            document.getElementById('regulatoryStrength').textContent = regulatoryStrength.toFixed(2);
        }

        // Initialize circadian charts with default values
        analyzeCircadianRhythm();
    </script>

    <script>
        // Navigation functionality
        document.addEventListener('DOMContentLoaded', function() {
            const navigationLinks = document.querySelectorAll('#navigation a');
            
            navigationLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    // Remove active class from all links
                    navigationLinks.forEach(l => l.classList.remove('active'));
                    
                    // Add active class to clicked link
                    this.classList.add('active');
                    
                    // Smooth scroll to target section
                    const targetId = this.getAttribute('href').substring(1);
                    const targetSection = document.getElementById(targetId);
                    
                    if (targetSection) {
                        targetSection.scrollIntoView({ 
                            behavior: 'smooth',
                            block: 'start'
                        });
                    }
                });
            });
            
            // Set initial active state
            const firstLink = document.querySelector('#navigation a');
            if (firstLink) {
                firstLink.classList.add('active');
            }
        });
    </script>
</body>
</html>

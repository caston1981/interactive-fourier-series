<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frequency Domain Analysis in Biology - Interactive Demos</title>

    <!-- MathJax Configuration -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

    <!-- Complex.js -->
    <script src="https://cdn.jsdelivr.net/npm/complex.js@2.1.1/complex.min.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        serif: ['Lora', 'serif'],
                    },
                    colors: {
                        'spectral-blue': '#2563EB',
                        'spectral-purple': '#7C3AED',
                        'spectral-green': '#059669',
                        'spectral-red': '#DC2626',
                        'bio-bg': '#F8FAFC',
                        'bio-text': '#374151',
                        'bio-heading': '#1F2937',
                    }
                }
            }
        }
    </script>

    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <!-- Top Navigation Bar for page switching -->
    <div class="w-full bg-[#F0EBE3] border-b border-gray-300 flex items-center justify-center py-2 px-4">
        <nav class="flex space-x-6">
            <a href="index.html" class="text-spectral-purple font-semibold hover:underline">Fourier Foundations</a>
            <a href="fdab.html" class="text-spectral-purple font-semibold hover:underline">FDA Biology Explorer</a>
            <a href="bio.html" class="text-spectral-purple font-semibold hover:underline">BioXen Fourier Explorer</a>
        </nav>
    </div>
    <div class="flex flex-col md:flex-row min-h-screen">
    <nav class="w-full md:w-64 bg-[#F0EBE3] p-4 md:p-6 flex-shrink-0">
        <h2 class="text-2xl font-bold mb-6 text-center md:text-left">FDA Biology</h2>
        <ul id="navigation" class="space-y-2">
            <li><a href="#psd" class="nav-link block p-3 rounded-lg font-medium">PSD Analysis</a></li>
            <li><a href="#wavelet" class="nav-link block p-3 rounded-lg font-medium">Wavelet Analysis</a></li>
            <li><a href="#hosa" class="nav-link block p-3 rounded-lg font-medium">Higher-Order Spectra</a></li>
            <li><a href="#graphs" class="nav-link block p-3 rounded-lg font-medium">Graph Theory</a></li>
            <li><a href="#circadian" class="nav-link block p-3 rounded-lg font-medium">Circadian Analysis</a></li>
        </ul>
    </nav>

    <main class="flex-1 p-6 md:p-10 overflow-y-auto">

        <!-- Hero Section -->
        <section class="text-center mb-12">
            <h1 class="text-4xl md:text-6xl font-bold text-bio-heading mb-4">
                Interactive Frequency Domain Analysis
            </h1>
            <p class="text-xl text-bio-text mb-8">
                Explore advanced spectral techniques applied to biological systems. This platform demonstrates key concepts from the comprehensive review on Frequency Domain Analysis in Systems Biology.
            </p>
            <div class="bg-spectral-purple/10 border-l-4 border-spectral-purple p-6 rounded-r-lg">
                <h2 class="font-semibold text-bio-heading mb-2">Learning Objectives</h2>
                <p class="text-sm">Master spectral decomposition, wavelet analysis, higher-order statistics, and their applications to biological time series, networks, and omics data.</p>
            </div>
        </section>

        <!-- PSD Analysis Section -->
        <section id="psd" class="mb-16">
            <div class="bg-white rounded-lg shadow-lg p-8">
                <h2 class="text-3xl font-bold text-bio-heading mb-4">üìä Power Spectral Density & Phase Coherence</h2>
                <p class="text-bio-text mb-6">
                    The foundation of frequency domain analysis is the Power Spectral Density (PSD), which quantifies how power is distributed across different frequencies. Phase coherence measures the reliability of oscillatory components in stochastic biological systems.
                </p>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Signal Generation</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Signal Type</label>
                                <select id="signalType" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="sine">Pure Sine Wave</option>
                                    <option value="square">Square Wave</option>
                                    <option value="sawtooth">Sawtooth Wave</option>
                                    <option value="noise">White Noise</option>
                                    <option value="biological">Biological Rhythm</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Frequency (Hz): <span id="freqValue">1.0</span></label>
                                <input type="range" id="frequency" min="0.1" max="10" step="0.1" value="1.0" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Noise Level: <span id="noiseValue">0.1</span></label>
                                <input type="range" id="noiseLevel" min="0" max="1" step="0.05" value="0.1" class="w-full">
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-xl font-semibold mb-4">Analysis Parameters</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Window Type</label>
                                <select id="windowType" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="hann">Hann Window</option>
                                    <option value="hamming">Hamming Window</option>
                                    <option value="blackman">Blackman Window</option>
                                    <option value="rectangular">Rectangular</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">FFT Size: <span id="fftValue">1024</span></label>
                                <input type="range" id="fftSize" min="256" max="4096" step="256" value="1024" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Overlap (%): <span id="overlapValue">50</span></label>
                                <input type="range" id="overlap" min="0" max="90" step="10" value="50" class="w-full">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 xl:grid-cols-2 gap-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Time Domain Signal</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="timeDomainChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Power Spectral Density</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="psdChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="mt-8 p-4 bg-gray-50 rounded-lg">
                    <h4 class="font-semibold mb-2">Phase Coherence Analysis</h4>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
                        <div>Dominant Frequency: <span id="dominantFreq" class="font-mono">1.00 Hz</span></div>
                        <div>Phase Coherence: <span id="phaseCoherence" class="font-mono">0.95</span></div>
                        <div>Signal-to-Noise Ratio: <span id="snr" class="font-mono">15.2 dB</span></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Wavelet Analysis Section -->
        <section id="wavelet" class="mb-16">
            <div class="bg-white rounded-lg shadow-lg p-8">
                <h2 class="text-3xl font-bold text-bio-heading mb-4">üåä Wavelet Analysis for Non-Stationary Signals</h2>
                <p class="text-bio-text mb-6">
                    Unlike Fourier analysis which assumes stationarity, wavelet transforms can localize spectral features in both time and frequency domains, making them ideal for analyzing transient biological phenomena like damping rhythms or burst events.
                </p>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Signal Parameters</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Wavelet Type</label>
                                <select id="waveletType" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="morlet">Morlet Wavelet</option>
                                    <option value="mexican">Mexican Hat</option>
                                    <option value="haar">Haar Wavelet</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Signal Type</label>
                                <select id="waveletSignalType" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="transient">Transient Event</option>
                                    <option value="chirp">Frequency Chirp</option>
                                    <option value="damping">Damping Oscillation</option>
                                    <option value="burst">Neural Burst</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Time Localization: <span id="timeLocValue">0.5</span></label>
                                <input type="range" id="timeLocalization" min="0.1" max="1.0" step="0.1" value="0.5" class="w-full">
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-xl font-semibold mb-4">Analysis Controls</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Frequency Resolution</label>
                                <input type="range" id="freqResolution" min="10" max="100" step="5" value="50" class="w-full">
                                <div class="text-xs text-gray-500 mt-1">Scales: <span id="scaleCount">50</span></div>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Color Scale</label>
                                <select id="colorScale" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="viridis">Viridis</option>
                                    <option value="plasma">Plasma</option>
                                    <option value="jet">Jet</option>
                                </select>
                            </div>
                            <button id="analyzeWavelet" class="bg-spectral-purple text-white px-4 py-2 rounded-md hover:bg-spectral-purple/80 transition-colors w-full">
                                Analyze Signal
                            </button>
                        </div>
                    </div>
                </div>

                <div class="space-y-6">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Time Domain Signal</h3>
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <canvas id="waveletTimeChart" class="w-full max-w-full" style="height: 200px;"></canvas>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-xl font-semibold mb-4">Time-Frequency Spectrogram</h3>
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <canvas id="waveletSpectrogram" class="w-full max-w-full" style="height: 250px;"></canvas>
                        </div>
                    </div>
                </div>

                <div class="mt-8 p-4 bg-gray-50 rounded-lg">
                    <h4 class="font-semibold mb-2">Wavelet Analysis Results</h4>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                        <div>Peak Frequency: <span id="peakFreq" class="font-mono">2.5 Hz</span></div>
                        <div>Time of Occurrence: <span id="eventTime" class="font-mono">1.2 s</span></div>
                        <div>Frequency Spread: <span id="freqSpread" class="font-mono">¬±0.8 Hz</span></div>
                        <div>Energy Concentration: <span id="energyConc" class="font-mono">78%</span></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- HOSA Section -->
        <section id="hosa" class="mb-16">
            <div class="bg-white rounded-lg shadow-lg p-8">
                <h2 class="text-3xl font-bold text-bio-heading mb-4">üîó Higher-Order Spectral Analysis (HOSA)</h2>
                <p class="text-bio-text mb-6">
                    Higher-Order Spectral Analysis goes beyond the Power Spectral Density to detect quadratic phase coupling (QPC) between frequencies. The bispectrum and bicoherence reveal nonlinear interactions that standard Fourier analysis cannot detect.
                </p>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Coupled Signal Generation</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Primary Frequency (f‚ÇÅ): <span id="f1Value">10</span> Hz</label>
                                <input type="range" id="freq1" min="5" max="50" step="1" value="10" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Secondary Frequency (f‚ÇÇ): <span id="f2Value">15</span> Hz</label>
                                <input type="range" id="freq2" min="5" max="50" step="1" value="15" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Coupling Strength: <span id="couplingStrengthValue">0.3</span></label>
                                <input type="range" id="couplingStrength" min="0" max="1" step="0.05" value="0.3" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Phase Offset: <span id="phaseOffsetValue">0</span>¬∞</label>
                                <input type="range" id="phaseOffset" min="0" max="360" step="15" value="0" class="w-full">
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-xl font-semibold mb-4">Analysis Method</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Analysis Type</label>
                                <select id="hosaType" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="bispectrum">Bispectrum</option>
                                    <option value="bicoherence">Bicoherence</option>
                                    <option value="cumulants">Cumulants</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Window Length: <span id="windowLengthValue">256</span></label>
                                <input type="range" id="windowLength" min="64" max="1024" step="64" value="256" class="w-full">
                            </div>
                            <div class="flex items-center space-x-2">
                                <input type="checkbox" id="showUncoupled" class="rounded">
                                <label for="showUncoupled" class="text-sm font-medium text-gray-700">Show Uncoupled Reference</label>
                            </div>
                            <button id="computeHOSA" class="bg-spectral-green text-white px-4 py-2 rounded-md hover:bg-spectral-green/80 transition-colors">
                                Compute HOSA
                            </button>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 xl:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Time Domain Signals</h3>
                        <div style="position: relative; height: 250px; width: 100%;">
                            <canvas id="hosaTimeChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Frequency Domain (PSD)</h3>
                        <div style="position: relative; height: 250px; width: 100%;">
                            <canvas id="hosaPSDChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 xl:grid-cols-2 gap-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Bispectrum Magnitude</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="bispectrumChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Bicoherence</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="bicoherenceChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="mt-8 p-4 bg-gray-50 rounded-lg">
                    <h4 class="font-semibold mb-2">HOSA Analysis Results</h4>
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4 text-sm">
                        <div>QPC Detected: <span id="qpcDetected" class="font-mono text-green-600">Yes</span></div>
                        <div>Bicoherence Peak: <span id="bicoherencePeak" class="font-mono">0.85</span></div>
                        <div>Coupling Frequency: <span id="couplingFreq" class="font-mono">25 Hz</span></div>
                        <div>Phase Coupling: <span id="phaseCoupling" class="font-mono">42¬∞</span></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Additional sections would go here -->
        <section id="graphs" class="mb-16">
            <div class="bg-white rounded-lg shadow-lg p-8">
                <h2 class="text-3xl font-bold text-bio-heading mb-4">üï∏Ô∏è Spectral Graph Theory in GRNs</h2>
                <p class="text-bio-text mb-6">
                    Spectral Graph Theory analyzes gene regulatory networks using eigenvalue decomposition of adjacency and Laplacian matrices. This reveals network connectivity patterns, prioritizes critical interactions, and provides robust analysis against molecular noise.
                </p>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Network Generation</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Network Type</label>
                                <select id="networkType" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="random">Random Network</option>
                                    <option value="scalefree">Scale-Free Network</option>
                                    <option value="smallworld">Small-World Network</option>
                                    <option value="modular">Modular Network</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Number of Genes: <span id="geneCountValue">20</span></label>
                                <input type="range" id="geneCount" min="10" max="50" step="5" value="20" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Connectivity: <span id="connectivityValue">0.3</span></label>
                                <input type="range" id="connectivity" min="0.1" max="0.8" step="0.05" value="0.3" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Noise Level: <span id="noiseLevelValue">0.1</span></label>
                                <input type="range" id="networkNoise" min="0" max="0.5" step="0.05" value="0.1" class="w-full">
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-xl font-semibold mb-4">Spectral Analysis</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Matrix Type</label>
                                <select id="matrixType" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="adjacency">Adjacency Matrix</option>
                                    <option value="laplacian">Laplacian Matrix</option>
                                    <option value="normalized">Normalized Laplacian</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Eigenvalue Range: <span id="eigenRangeValue">10</span></label>
                                <input type="range" id="eigenRange" min="5" max="20" step="1" value="10" class="w-full">
                            </div>
                            <div class="flex items-center space-x-2">
                                <input type="checkbox" id="showEigenvectors" class="rounded">
                                <label for="showEigenvectors" class="text-sm font-medium text-gray-700">Show Eigenvector Analysis</label>
                            </div>
                            <button id="analyzeNetwork" class="bg-spectral-purple text-white px-4 py-2 rounded-md hover:bg-spectral-purple/80 transition-colors w-full">
                                Analyze Network
                            </button>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 xl:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Network Visualization</h3>
                        <div style="position: relative; height: 350px; width: 100%;">
                            <canvas id="networkChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Eigenvalue Spectrum</h3>
                        <div style="position: relative; height: 350px; width: 100%;">
                            <canvas id="eigenvalueChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 xl:grid-cols-2 gap-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Adjacency Matrix</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="adjacencyChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Network Metrics</h3>
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <div class="grid grid-cols-2 gap-4 text-sm">
                                <div>Clustering Coefficient: <span id="clusteringCoeff" class="font-mono">0.00</span></div>
                                <div>Average Path Length: <span id="avgPathLength" class="font-mono">0.00</span></div>
                                <div>Spectral Gap: <span id="spectralGap" class="font-mono">0.00</span></div>
                                <div>Algebraic Connectivity: <span id="algebraicConn" class="font-mono">0.00</span></div>
                                <div>Network Diameter: <span id="networkDiameter" class="font-mono">0</span></div>
                                <div>Robustness Score: <span id="robustnessScore" class="font-mono">0.00</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="circadian" class="mb-16">
            <div class="bg-white rounded-lg shadow-lg p-8">
                <h2 class="text-3xl font-bold text-bio-heading mb-4">‚è∞ Circadian Rhythm Analysis</h2>
                <p class="text-bio-text mb-6">
                    Circadian rhythms are biological oscillations with periods of approximately 24 hours. This interactive tool demonstrates spectral analysis of circadian signals, including period detection, phase coherence, and damping rhythm analysis using concepts from specialized tools like Rhythmidia.
                </p>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Circadian Signal Parameters</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Circadian Period (hours): <span id="periodValue">24.0</span></label>
                                <input type="range" id="circadianPeriod" min="20" max="28" step="0.5" value="24.0" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Amplitude Damping: <span id="dampingValue">0.1</span></label>
                                <input type="range" id="amplitudeDamping" min="0" max="0.5" step="0.05" value="0.1" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Phase Noise: <span id="phaseNoiseValue">0.2</span></label>
                                <input type="range" id="phaseNoise" min="0" max="1" step="0.05" value="0.2" class="w-full">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Observation Days: <span id="daysValue">7</span></label>
                                <input type="range" id="observationDays" min="3" max="14" step="1" value="7" class="w-full">
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-xl font-semibold mb-4">Analysis Method</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Analysis Type</label>
                                <select id="circadianAnalysisType" class="w-full p-2 border border-gray-300 rounded-md">
                                    <option value="periodogram">Periodogram Analysis</option>
                                    <option value="wavelet">Wavelet Transform</option>
                                    <option value="autocorr">Autocorrelation</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Sampling Rate (samples/hour): <span id="samplingValue">4</span></label>
                                <input type="range" id="samplingRate" min="1" max="12" step="1" value="4" class="w-full">
                            </div>
                            <div class="flex items-center space-x-2">
                                <input type="checkbox" id="showDamping" class="rounded">
                                <label for="showDamping" class="text-sm font-medium text-gray-700">Show Damping Analysis</label>
                            </div>
                            <button id="analyzeCircadian" class="bg-bio-green text-white px-4 py-2 rounded-md hover:bg-bio-green/80 transition-colors w-full">
                                Analyze Circadian Rhythm
                            </button>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 xl:grid-cols-2 gap-8 mb-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Time Domain Signal</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="circadianTimeChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Periodogram Analysis</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="circadianPeriodogram"></canvas>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 xl:grid-cols-2 gap-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Phase Distribution</h3>
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="circadianPhaseChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-4">Rhythm Metrics</h3>
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <div class="grid grid-cols-2 gap-4 text-sm">
                                <div>Detected Period: <span id="detectedPeriod" class="font-mono text-bio-green">24.0 h</span></div>
                                <div>Phase Coherence: <span id="phaseCoherence" class="font-mono">0.85</span></div>
                                <div>Amplitude Stability: <span id="amplitudeStability" class="font-mono">78%</span></div>
                                <div>Rhythm Strength: <span id="rhythmStrength" class="font-mono">0.92</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

    </main>
    </div>

    <!-- Footer -->
    <footer class="bg-gray-800 text-white py-8">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="text-center">
                <p class="text-gray-400">Interactive Frequency Domain Analysis in Biology</p>
                <p class="text-sm text-gray-500 mt-2">Based on the comprehensive review "Spectral Dynamics in Systems Biology"</p>
            </div>
        </div>
    </footer>

    <script>
        // Global chart instances
        let timeDomainChart, psdChart, waveletTimeChart, waveletSpectrogram, hosaTimeChart, hosaPSDChart, bispectrumChart, bicoherenceChart, circadianTimeChart, circadianPeriodogram, circadianPhaseChart, networkChart, eigenvalueChart, adjacencyChart;

        // Initialize all charts and controls
        document.addEventListener('DOMContentLoaded', function() {
            initializeCharts();
            setupEventListeners();
            updatePSD(); // Initial render
        });

        // Debounce utility function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function initializeCharts() {
            // PSD Analysis Charts
            const timeCtx = document.getElementById('timeDomainChart').getContext('2d');
            timeDomainChart = new Chart(timeCtx, {
                type: 'line',
                data: { datasets: [{ label: 'Signal', data: [], borderColor: 'rgb(75, 192, 192)', tension: 0.1, pointRadius: 0 }] },
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Time (s)' } },
                        y: { title: { display: true, text: 'Amplitude' } }
                    },
                    elements: { point: { radius: 0 } }
                }
            });

            const psdCtx = document.getElementById('psdChart').getContext('2d');
            psdChart = new Chart(psdCtx, {
                type: 'line',
                data: { datasets: [{ label: 'PSD', data: [], borderColor: 'rgb(153, 102, 255)', tension: 0.1 }] },
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    scales: { 
                        x: { 
                            type: 'logarithmic',
                            min: 0.1,
                            max: 500,
                            title: { display: true, text: 'Frequency (Hz)' }
                        },
                        y: {
                            type: 'logarithmic',
                            min: 0.001,
                            max: 10,
                            title: { display: true, text: 'Power' }
                        }
                    }
                }
            });

            // Wavelet Charts
            const waveletTimeCtx = document.getElementById('waveletTimeChart').getContext('2d');
            waveletTimeChart = new Chart(waveletTimeCtx, {
                type: 'line',
                data: { datasets: [{ label: 'Signal', data: [], borderColor: 'rgb(255, 159, 64)' }] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Time (s)' } },
                        y: { title: { display: true, text: 'Amplitude' } }
                    }
                }
            });

            // HOSA Charts
            const hosaTimeCtx = document.getElementById('hosaTimeChart').getContext('2d');
            hosaTimeChart = new Chart(hosaTimeCtx, {
                type: 'line',
                data: {
                    datasets: [
                        { label: 'Signal 1', data: [], borderColor: 'rgb(255, 99, 132)', borderWidth: 1, pointRadius: 0 },
                        { label: 'Signal 2', data: [], borderColor: 'rgb(54, 162, 235)', borderWidth: 1, pointRadius: 0 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'top' }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Time (s)' },
                            ticks: { maxTicksLimit: 10 }
                        },
                        y: {
                            title: { display: true, text: 'Amplitude' },
                            min: -2,
                            max: 2
                        }
                    },
                    elements: {
                        point: { radius: 0 }
                    }
                }
            });

            const hosaPSDCtx = document.getElementById('hosaPSDChart').getContext('2d');
            hosaPSDChart = new Chart(hosaPSDCtx, {
                type: 'line',
                data: {
                    datasets: [
                        { label: 'PSD 1', data: [], borderColor: 'rgb(255, 99, 132)', borderWidth: 1, pointRadius: 0 },
                        { label: 'PSD 2', data: [], borderColor: 'rgb(54, 162, 235)', borderWidth: 1, pointRadius: 0 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'top' }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: { display: true, text: 'Frequency (Hz)' },
                            min: 0,
                            max: 100,
                            ticks: { maxTicksLimit: 10 }
                        },
                        y: {
                            type: 'logarithmic',
                            title: { display: true, text: 'Power' },
                            min: 0.001,
                            max: 10
                        }
                    },
                    elements: {
                        point: { radius: 0 }
                    }
                }
            });

            // Bispectrum Chart
            const bispectrumCtx = document.getElementById('bispectrumChart').getContext('2d');
            bispectrumChart = new Chart(bispectrumCtx, {
                type: 'bubble',
                data: {
                    datasets: [{
                        label: 'Bispectrum',
                        data: [],
                        backgroundColor: 'rgba(75, 192, 192, 0.6)',
                        borderColor: 'rgba(75, 192, 192, 1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Frequency f1 (Hz)' }, min: 0, max: 50 },
                        y: { title: { display: true, text: 'Frequency f2 (Hz)' }, min: 0, max: 50 }
                    }
                }
            });

            // Bicoherence Chart
            const bicoherenceCtx = document.getElementById('bicoherenceChart').getContext('2d');
            bicoherenceChart = new Chart(bicoherenceCtx, {
                type: 'bubble',
                data: {
                    datasets: [{
                        label: 'Bicoherence',
                        data: [],
                        backgroundColor: 'rgba(153, 102, 255, 0.6)',
                        borderColor: 'rgba(153, 102, 255, 1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Frequency f1 (Hz)' }, min: 0, max: 50 },
                        y: { title: { display: true, text: 'Frequency f2 (Hz)' }, min: 0, max: 50 }
                    }
                }
            });

            // Circadian Charts
            const circadianTimeCtx = document.getElementById('circadianTimeChart').getContext('2d');
            circadianTimeChart = new Chart(circadianTimeCtx, {
                type: 'line',
                data: { datasets: [{ label: 'Circadian Signal', data: [], borderColor: 'rgb(34, 197, 94)', tension: 0.1, pointRadius: 0 }] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Time (hours)' } },
                        y: { title: { display: true, text: 'Amplitude' } }
                    },
                    elements: { point: { radius: 0 } }
                }
            });

            const circadianPeriodogramCtx = document.getElementById('circadianPeriodogram').getContext('2d');
            circadianPeriodogram = new Chart(circadianPeriodogramCtx, {
                type: 'line',
                data: { datasets: [{ label: 'Periodogram', data: [], borderColor: 'rgb(168, 85, 247)', tension: 0.1 }] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Period (hours)' }, min: 20, max: 28 },
                        y: { title: { display: true, text: 'Power' } }
                    }
                }
            });

            const circadianPhaseCtx = document.getElementById('circadianPhaseChart').getContext('2d');
            circadianPhaseChart = new Chart(circadianPhaseCtx, {
                type: 'bar',
                data: {
                    labels: Array.from({length: 24}, (_, i) => `${i}:00`),
                    datasets: [{
                        label: 'Phase Distribution',
                        data: [],
                        backgroundColor: 'rgba(34, 197, 94, 0.6)',
                        borderColor: 'rgba(34, 197, 94, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Hour of Day' } },
                        y: { title: { display: true, text: 'Activity Level' } }
                    },
                    plugins: {
                        legend: { display: false }
                    }
                }
            });

            // Spectral Graph Theory Charts
            const networkCtx = document.getElementById('networkChart').getContext('2d');
            networkChart = new Chart(networkCtx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Gene Nodes',
                        data: [],
                        backgroundColor: 'rgba(139, 92, 246, 0.8)',
                        borderColor: 'rgba(139, 92, 246, 1)',
                        pointRadius: 8
                    }, {
                        label: 'Edges',
                        data: [],
                        type: 'line',
                        backgroundColor: 'rgba(156, 163, 175, 0.3)',
                        borderColor: 'rgba(156, 163, 175, 0.5)',
                        borderWidth: 1,
                        pointRadius: 0,
                        showLine: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { min: -1.2, max: 1.2, title: { display: true, text: 'X Position' } },
                        y: { min: -1.2, max: 1.2, title: { display: true, text: 'Y Position' } }
                    }
                }
            });

            const eigenvalueCtx = document.getElementById('eigenvalueChart').getContext('2d');
            eigenvalueChart = new Chart(eigenvalueCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Eigenvalues',
                        data: [],
                        backgroundColor: 'rgba(245, 101, 101, 0.8)',
                        borderColor: 'rgba(245, 101, 101, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Index' } },
                        y: { title: { display: true, text: 'Eigenvalue' } }
                    },
                    plugins: {
                        legend: { display: false }
                    }
                }
            });

            const adjacencyCtx = document.getElementById('adjacencyChart').getContext('2d');
            adjacencyChart = new Chart(adjacencyCtx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Matrix Entries',
                        data: [],
                        backgroundColor: 'rgba(34, 197, 94, 0.8)',
                        borderColor: 'rgba(34, 197, 94, 1)',
                        pointRadius: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Gene i' }, min: 0 },
                        y: { title: { display: true, text: 'Gene j' }, min: 0 }
                    }
                }
            });
        }

        function setupEventListeners() {
            // PSD controls - use debounced update for performance
            const debouncedUpdatePSD = debounce(updatePSD, 150);
            ['signalType', 'frequency', 'noiseLevel', 'windowType', 'fftSize', 'overlap'].forEach(id => {
                document.getElementById(id).addEventListener('input', debouncedUpdatePSD);
            });

            // Update display values (immediate, no debounce needed)
            document.getElementById('frequency').addEventListener('input', function() {
                document.getElementById('freqValue').textContent = this.value;
            });
            document.getElementById('noiseLevel').addEventListener('input', function() {
                document.getElementById('noiseValue').textContent = this.value;
            });
            document.getElementById('fftSize').addEventListener('input', function() {
                document.getElementById('fftValue').textContent = this.value;
            });
            document.getElementById('overlap').addEventListener('input', function() {
                document.getElementById('overlapValue').textContent = this.value;
            });

            // HOSA controls
            ['freq1', 'freq2', 'couplingStrength', 'phaseOffset', 'hosaType', 'windowLength'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateHOSA);
            });

            document.getElementById('computeHOSA').addEventListener('click', updateHOSA);

            // Update HOSA display values
            document.getElementById('freq1').addEventListener('input', function() {
                document.getElementById('f1Value').textContent = this.value;
            });
            document.getElementById('freq2').addEventListener('input', function() {
                document.getElementById('f2Value').textContent = this.value;
            });
            document.getElementById('couplingStrength').addEventListener('input', function() {
                document.getElementById('couplingStrengthValue').textContent = this.value;
            });
            document.getElementById('phaseOffset').addEventListener('input', function() {
                document.getElementById('phaseOffsetValue').textContent = this.value;
            });
            document.getElementById('windowLength').addEventListener('input', function() {
                document.getElementById('windowLengthValue').textContent = this.value;
            });

            // Circadian controls
            ['circadianPeriod', 'amplitudeDamping', 'phaseNoise', 'observationDays', 'samplingRate'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateCircadianDisplay);
            });

            document.getElementById('analyzeCircadian').addEventListener('click', analyzeCircadianRhythm);

            // Update circadian display values
            document.getElementById('circadianPeriod').addEventListener('input', function() {
                document.getElementById('periodValue').textContent = this.value;
            });
            document.getElementById('amplitudeDamping').addEventListener('input', function() {
                document.getElementById('dampingValue').textContent = this.value;
            });
            document.getElementById('phaseNoise').addEventListener('input', function() {
                document.getElementById('phaseNoiseValue').textContent = this.value;
            });
            document.getElementById('observationDays').addEventListener('input', function() {
                document.getElementById('daysValue').textContent = this.value;
            });
            document.getElementById('samplingRate').addEventListener('input', function() {
                document.getElementById('samplingValue').textContent = this.value;
            });

            // Spectral Graph Theory controls
            ['geneCount', 'connectivity', 'networkNoise', 'eigenRange'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateNetworkDisplay);
            });

            document.getElementById('analyzeNetwork').addEventListener('click', analyzeNetwork);

            // Update network display values
            document.getElementById('geneCount').addEventListener('input', function() {
                document.getElementById('geneCountValue').textContent = this.value;
            });
            document.getElementById('connectivity').addEventListener('input', function() {
                document.getElementById('connectivityValue').textContent = this.value;
            });
            document.getElementById('networkNoise').addEventListener('input', function() {
                document.getElementById('noiseLevelValue').textContent = this.value;
            });
            document.getElementById('eigenRange').addEventListener('input', function() {
                document.getElementById('eigenRangeValue').textContent = this.value;
            });
        }

        function updatePSD() {
            const signalType = document.getElementById('signalType').value;
            const frequency = parseFloat(document.getElementById('frequency').value);
            const noiseLevel = parseFloat(document.getElementById('noiseLevel').value);
            const fftSize = parseInt(document.getElementById('fftSize').value);

            // Generate signal
            const sampleRate = 1000; // Hz
            const duration = 2; // seconds
            const numSamples = sampleRate * duration;
            const time = Array.from({length: numSamples}, (_, i) => i / sampleRate);

            let signal = [];
            for (let t of time) {
                let value = 0;
                switch (signalType) {
                    case 'sine':
                        value = Math.sin(2 * Math.PI * frequency * t);
                        break;
                    case 'square':
                        value = Math.sign(Math.sin(2 * Math.PI * frequency * t));
                        break;
                    case 'sawtooth':
                        value = 2 * (t * frequency - Math.floor(t * frequency + 0.5));
                        break;
                    case 'noise':
                        value = (Math.random() - 0.5) * 2;
                        break;
                    case 'biological':
                        value = Math.sin(2 * Math.PI * frequency * t) + 0.3 * Math.sin(2 * Math.PI * 2 * frequency * t);
                        break;
                }
                // Add noise
                value += noiseLevel * (Math.random() - 0.5) * 2;
                signal.push(value);
            }

            // Update time domain chart
            timeDomainChart.data.labels = time.filter((_, i) => i % 10 === 0); // Downsample for display
            timeDomainChart.data.datasets[0].data = signal.filter((_, i) => i % 10 === 0);
            timeDomainChart.update();

            // Compute PSD (simplified)
            const psd = computePSD(signal, fftSize, sampleRate);
            const freqs = Array.from({length: psd.length}, (_, i) => Math.max(0.1, i * sampleRate / fftSize)); // Avoid zero for log scale

            psdChart.data.labels = freqs;
            psdChart.data.datasets[0].data = psd;
            psdChart.update();

            // Update analysis results
            const maxIdx = psd.indexOf(Math.max(...psd));
            document.getElementById('dominantFreq').textContent = freqs[maxIdx].toFixed(2) + ' Hz';
            document.getElementById('phaseCoherence').textContent = '0.95'; // Placeholder
            document.getElementById('snr').textContent = '15.2 dB'; // Placeholder
        }

        function computePSD(signal, fftSize, sampleRate) {
            // Simplified PSD computation using autocorrelation method
            const psd = new Array(fftSize / 2).fill(0);

            // Simple periodogram
            for (let k = 1; k < fftSize / 2; k++) {
                let real = 0, imag = 0;
                for (let n = 0; n < Math.min(signal.length, fftSize); n++) {
                    const angle = -2 * Math.PI * k * n / fftSize;
                    real += signal[n] * Math.cos(angle);
                    imag += signal[n] * Math.sin(angle);
                }
                psd[k] = (real * real + imag * imag) / fftSize;
            }

            return psd;
        }

        function updateHOSA() {
            const f1 = parseFloat(document.getElementById('freq1').value);
            const f2 = parseFloat(document.getElementById('freq2').value);
            const coupling = parseFloat(document.getElementById('couplingStrength').value);
            const phaseOffset = parseFloat(document.getElementById('phaseOffset').value) * Math.PI / 180;

            const sampleRate = 1000;
            const duration = 1;
            const numSamples = sampleRate * duration;
            const time = Array.from({length: numSamples}, (_, i) => i / sampleRate);

            // Generate coupled signals
            let signal1 = [], signal2 = [];
            for (let t of time) {
                const s1 = Math.sin(2 * Math.PI * f1 * t);
                const s2 = Math.sin(2 * Math.PI * f2 * t + phaseOffset);

                // Add quadratic coupling
                const coupled_s1 = s1 + coupling * s1 * s2;
                const coupled_s2 = s2 + coupling * s1 * s2;

                signal1.push(coupled_s1);
                signal2.push(coupled_s2);
            }

            // Update time domain chart
            hosaTimeChart.data.labels = time.filter((_, i) => i % 10 === 0);
            hosaTimeChart.data.datasets[0].data = signal1.filter((_, i) => i % 10 === 0);
            hosaTimeChart.data.datasets[1].data = signal2.filter((_, i) => i % 10 === 0);
            hosaTimeChart.update();

            // Compute PSDs
            const psd1 = computePSD(signal1, 256, sampleRate);
            const psd2 = computePSD(signal2, 256, sampleRate);
            const freqs = Array.from({length: psd1.length}, (_, i) => i * sampleRate / 256);

            hosaPSDChart.data.labels = freqs;
            hosaPSDChart.data.datasets[0].data = psd1;
            hosaPSDChart.data.datasets[1].data = psd2;
            hosaPSDChart.update();

            // Update results
            document.getElementById('qpcDetected').textContent = coupling > 0.1 ? 'Yes' : 'No';
            document.getElementById('bicoherencePeak').textContent = (coupling * 0.8).toFixed(2);
            document.getElementById('couplingFreq').textContent = (f1 + f2) + ' Hz';
            document.getElementById('phaseCoupling').textContent = (phaseOffset * 180 / Math.PI).toFixed(0) + '¬∞';

            // Generate bispectrum data (simplified for demo)
            const bispectrumData = [];
            const bicoherenceData = [];
            const numPoints = 20; // Reduced for performance

            for (let i = 0; i < numPoints; i++) {
                for (let j = 0; j < numPoints; j++) {
                    const f1_val = (i / numPoints) * 50;
                    const f2_val = (j / numPoints) * 50;

                    // Simplified bispectrum calculation
                    const bispectrum = coupling * Math.exp(-Math.abs(f1_val - f1) / 10) * Math.exp(-Math.abs(f2_val - f2) / 10);
                    const bicoherence = Math.min(1, bispectrum / (coupling + 0.1));

                    if (bispectrum > 0.05) {
                        bispectrumData.push({ x: f1_val, y: f2_val, r: Math.max(1, bispectrum * 10) });
                    }
                    if (bicoherence > 0.2) {
                        bicoherenceData.push({ x: f1_val, y: f2_val, r: Math.max(1, bicoherence * 10) });
                    }
                }
            }

            bispectrumChart.data.datasets[0].data = bispectrumData;
            bispectrumChart.update();

            bicoherenceChart.data.datasets[0].data = bicoherenceData;
            bicoherenceChart.update();
        }

        function updateCircadianDisplay() {
            // Update display values for circadian controls
            document.getElementById('periodValue').textContent = document.getElementById('circadianPeriod').value;
            document.getElementById('dampingValue').textContent = document.getElementById('amplitudeDamping').value;
            document.getElementById('phaseNoiseValue').textContent = document.getElementById('phaseNoise').value;
            document.getElementById('daysValue').textContent = document.getElementById('observationDays').value;
            document.getElementById('samplingValue').textContent = document.getElementById('samplingRate').value;
        }

        function analyzeCircadianRhythm() {
            const period = parseFloat(document.getElementById('circadianPeriod').value);
            const damping = parseFloat(document.getElementById('amplitudeDamping').value);
            const phaseNoise = parseFloat(document.getElementById('phaseNoise').value);
            const days = parseInt(document.getElementById('observationDays').value);
            const samplingRate = parseInt(document.getElementById('samplingRate').value);

            // Generate circadian signal
            const signal = generateCircadianSignal(period, damping, phaseNoise, days, samplingRate);
            const timeHours = Array.from({length: signal.length}, (_, i) => i / samplingRate);

            // Update time domain chart
            circadianTimeChart.data.labels = timeHours;
            circadianTimeChart.data.datasets[0].data = signal;
            circadianTimeChart.update();

            // Compute periodogram
            const periodogram = computeCircadianPeriodogram(signal, samplingRate);
            const periods = Array.from({length: periodogram.length}, (_, i) => 20 + i * 0.1);

            circadianPeriodogram.data.labels = periods;
            circadianPeriodogram.data.datasets[0].data = periodogram;
            circadianPeriodogram.update();

            // Analyze phase distribution
            const phases = analyzeCircadianPhases(signal, period, samplingRate);
            circadianPhaseChart.data.datasets[0].data = phases;
            circadianPhaseChart.update();

            // Update metrics
            const detectedPeriod = detectCircadianPeriod(periodogram, periods);
            const coherence = calculatePhaseCoherence(signal, period, samplingRate);
            const stability = calculateAmplitudeStability(signal);
            const strength = Math.max(...periodogram) / periodogram.reduce((a, b) => a + b, 0) * periodogram.length;

            document.getElementById('detectedPeriod').textContent = detectedPeriod.toFixed(1) + ' h';
            document.getElementById('phaseCoherence').textContent = coherence.toFixed(2);
            document.getElementById('amplitudeStability').textContent = (stability * 100).toFixed(0) + '%';
            document.getElementById('rhythmStrength').textContent = strength.toFixed(2);
        }

        function generateCircadianSignal(period, damping, phaseNoise, days, samplingRate) {
            const totalHours = days * 24;
            const numSamples = totalHours * samplingRate;
            const signal = [];

            for (let i = 0; i < numSamples; i++) {
                const time = i / samplingRate;
                const cycles = time / period;

                // Base circadian oscillation
                let amplitude = Math.exp(-damping * cycles); // Damping over cycles
                let phase = 2 * Math.PI * cycles + (Math.random() - 0.5) * phaseNoise * 2 * Math.PI;

                const value = amplitude * Math.sin(phase);
                signal.push(value);
            }

            return signal;
        }

        function computeCircadianPeriodogram(signal, samplingRate) {
            // Simple periodogram for circadian range (20-28 hours)
            const periods = [];
            for (let p = 20; p <= 28; p += 0.1) {
                periods.push(p);
            }

            const periodogram = periods.map(period => {
                const freq = 1 / period;
                let real = 0, imag = 0;

                for (let i = 0; i < signal.length; i++) {
                    const time = i / samplingRate;
                    const angle = -2 * Math.PI * freq * time;
                    real += signal[i] * Math.cos(angle);
                    imag += signal[i] * Math.sin(angle);
                }

                return (real * real + imag * imag) / signal.length;
            });

            return periodogram;
        }

        function analyzeCircadianPhases(signal, period, samplingRate) {
            // Analyze phase distribution over 24 hours
            const phases = new Array(24).fill(0);
            const freq = 1 / period;

            for (let i = 0; i < signal.length; i++) {
                const time = i / samplingRate;
                const phase = (freq * time * 24) % 24; // Phase in hours
                const bin = Math.floor(phase);
                if (bin >= 0 && bin < 24) {
                    phases[bin] += Math.abs(signal[i]);
                }
            }

            return phases;
        }

        function detectCircadianPeriod(periodogram, periods) {
            const maxIndex = periodogram.indexOf(Math.max(...periodogram));
            return periods[maxIndex];
        }

        function calculatePhaseCoherence(signal, period, samplingRate) {
            // Simplified phase coherence calculation
            const freq = 1 / period;
            let coherenceSum = 0;
            let count = 0;

            for (let i = 0; i < signal.length - samplingRate * period; i += samplingRate) {
                const phase1 = Math.atan2(
                    signal.slice(i, i + samplingRate).reduce((sum, val, idx) => sum + val * Math.sin(2 * Math.PI * freq * idx / samplingRate), 0),
                    signal.slice(i, i + samplingRate).reduce((sum, val, idx) => sum + val * Math.cos(2 * Math.PI * freq * idx / samplingRate), 0)
                );

                const phase2 = Math.atan2(
                    signal.slice(i + samplingRate * period, i + 2 * samplingRate * period).reduce((sum, val, idx) => sum + val * Math.sin(2 * Math.PI * freq * (idx + samplingRate * period) / samplingRate), 0),
                    signal.slice(i + samplingRate * period, i + 2 * samplingRate * period).reduce((sum, val, idx) => sum + val * Math.cos(2 * Math.PI * freq * (idx + samplingRate * period) / samplingRate), 0)
                );

                coherenceSum += Math.cos(phase1 - phase2);
                count++;
            }

            return count > 0 ? Math.abs(coherenceSum / count) : 0;
        }

        function calculateAmplitudeStability(signal) {
            // Calculate coefficient of variation of local maxima
            const peaks = [];
            for (let i = 1; i < signal.length - 1; i++) {
                if (signal[i] > signal[i-1] && signal[i] > signal[i+1] && signal[i] > 0) {
                    peaks.push(signal[i]);
                }
            }

            if (peaks.length < 2) return 0;

            const mean = peaks.reduce((a, b) => a + b, 0) / peaks.length;
            const variance = peaks.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / peaks.length;
            const cv = Math.sqrt(variance) / mean;

            return Math.max(0, 1 - cv); // Convert to stability score
        }

        // Initialize HOSA charts with default values
        updateHOSA();

        function updateNetworkDisplay() {
            // Update display values for network controls
            document.getElementById('geneCountValue').textContent = document.getElementById('geneCount').value;
            document.getElementById('connectivityValue').textContent = document.getElementById('connectivity').value;
            document.getElementById('noiseLevelValue').textContent = document.getElementById('networkNoise').value;
            document.getElementById('eigenRangeValue').textContent = document.getElementById('eigenRange').value;
        }

        function analyzeNetwork() {
            const networkType = document.getElementById('networkType').value;
            const geneCount = parseInt(document.getElementById('geneCount').value);
            const connectivity = parseFloat(document.getElementById('connectivity').value);
            const noiseLevel = parseFloat(document.getElementById('networkNoise').value);
            const matrixType = document.getElementById('matrixType').value;
            const eigenRange = parseInt(document.getElementById('eigenRange').value);

            // Generate network
            const network = generateNetwork(networkType, geneCount, connectivity, noiseLevel);

            // Compute spectral properties
            const spectralData = computeSpectralProperties(network, matrixType, eigenRange);

            // Update visualizations
            updateNetworkVisualization(network);
            updateEigenvalueVisualization(spectralData.eigenvalues, eigenRange);
            updateAdjacencyVisualization(network.adjacencyMatrix);

            // Update metrics
            updateNetworkMetrics(network, spectralData);
        }

        function generateNetwork(type, size, connectivity, noise) {
            const network = {
                nodes: [],
                edges: [],
                adjacencyMatrix: []
            };

            // Initialize adjacency matrix
            for (let i = 0; i < size; i++) {
                network.adjacencyMatrix[i] = new Array(size).fill(0);
            }

            // Generate node positions (circular layout)
            for (let i = 0; i < size; i++) {
                const angle = (2 * Math.PI * i) / size;
                const radius = 0.8;
                network.nodes.push({
                    id: i,
                    x: radius * Math.cos(angle) + (Math.random() - 0.5) * noise,
                    y: radius * Math.sin(angle) + (Math.random() - 0.5) * noise
                });
            }

            // Generate connections based on network type
            switch (type) {
                case 'random':
                    generateRandomNetwork(network, connectivity, noise);
                    break;
                case 'scalefree':
                    generateScaleFreeNetwork(network, connectivity, noise);
                    break;
                case 'smallworld':
                    generateSmallWorldNetwork(network, connectivity, noise);
                    break;
                case 'modular':
                    generateModularNetwork(network, connectivity, noise);
                    break;
            }

            return network;
        }

        function generateRandomNetwork(network, connectivity, noise) {
            const size = network.nodes.length;
            for (let i = 0; i < size; i++) {
                for (let j = i + 1; j < size; j++) {
                    if (Math.random() < connectivity) {
                        const weight = 1 + (Math.random() - 0.5) * noise;
                        network.adjacencyMatrix[i][j] = weight;
                        network.adjacencyMatrix[j][i] = weight;
                        network.edges.push({ source: i, target: j, weight: weight });
                    }
                }
            }
        }

        function generateScaleFreeNetwork(network, connectivity, noise) {
            const size = network.nodes.length;
            // Start with a small fully connected core
            const coreSize = Math.min(3, size);
            for (let i = 0; i < coreSize; i++) {
                for (let j = i + 1; j < coreSize; j++) {
                    network.adjacencyMatrix[i][j] = 1;
                    network.adjacencyMatrix[j][i] = 1;
                    network.edges.push({ source: i, target: j, weight: 1 });
                }
            }

            // Add remaining nodes with preferential attachment
            for (let i = coreSize; i < size; i++) {
                const degrees = network.adjacencyMatrix.map(row => row.reduce((sum, val) => sum + val, 0));
                const totalDegree = degrees.reduce((sum, deg) => sum + deg, 0);

                for (let j = 0; j < i; j++) {
                    const attachmentProb = degrees[j] / totalDegree;
                    if (Math.random() < attachmentProb * connectivity * 2) {
                        const weight = 1 + (Math.random() - 0.5) * noise;
                        network.adjacencyMatrix[i][j] = weight;
                        network.adjacencyMatrix[j][i] = weight;
                        network.edges.push({ source: i, target: j, weight: weight });
                    }
                }
            }
        }

        function generateSmallWorldNetwork(network, connectivity, noise) {
            const size = network.nodes.length;
            const k = Math.floor(connectivity * size / 2); // Average degree

            // Create regular ring lattice
            for (let i = 0; i < size; i++) {
                for (let j = 1; j <= k; j++) {
                    const neighbor = (i + j) % size;
                    const weight = 1 + (Math.random() - 0.5) * noise;
                    network.adjacencyMatrix[i][neighbor] = weight;
                    network.adjacencyMatrix[neighbor][i] = weight;
                    network.edges.push({ source: i, target: neighbor, weight: weight });
                }
            }

            // Add random rewiring (Watts-Strogatz model)
            for (let i = 0; i < size; i++) {
                for (let j = 1; j <= k; j++) {
                    if (Math.random() < 0.1) { // Rewiring probability
                        const neighbor = (i + j) % size;
                        network.adjacencyMatrix[i][neighbor] = 0;
                        network.adjacencyMatrix[neighbor][i] = 0;

                        // Find new random connection
                        let newNeighbor;
                        do {
                            newNeighbor = Math.floor(Math.random() * size);
                        } while (newNeighbor === i || network.adjacencyMatrix[i][newNeighbor] > 0);

                        const weight = 1 + (Math.random() - 0.5) * noise;
                        network.adjacencyMatrix[i][newNeighbor] = weight;
                        network.adjacencyMatrix[newNeighbor][i] = weight;
                        network.edges.push({ source: i, target: newNeighbor, weight: weight });
                    }
                }
            }
        }

        function generateModularNetwork(network, connectivity, noise) {
            const size = network.nodes.length;
            const modules = Math.max(2, Math.floor(size / 10)); // Number of modules
            const moduleSize = Math.floor(size / modules);

            for (let m = 0; m < modules; m++) {
                const startIdx = m * moduleSize;
                const endIdx = Math.min((m + 1) * moduleSize, size);

                // Dense connections within modules
                for (let i = startIdx; i < endIdx; i++) {
                    for (let j = i + 1; j < endIdx; j++) {
                        if (Math.random() < connectivity * 2) {
                            const weight = 1 + (Math.random() - 0.5) * noise;
                            network.adjacencyMatrix[i][j] = weight;
                            network.adjacencyMatrix[j][i] = weight;
                            network.edges.push({ source: i, target: j, weight: weight });
                        }
                    }
                }

                // Sparse connections between modules
                if (m < modules - 1) {
                    const nextStart = (m + 1) * moduleSize;
                    for (let i = startIdx; i < endIdx; i++) {
                        for (let j = nextStart; j < Math.min(nextStart + moduleSize, size); j++) {
                            if (Math.random() < connectivity * 0.1) {
                                const weight = 1 + (Math.random() - 0.5) * noise;
                                network.adjacencyMatrix[i][j] = weight;
                                network.adjacencyMatrix[j][i] = weight;
                                network.edges.push({ source: i, target: j, weight: weight });
                            }
                        }
                    }
                }
            }
        }

        function computeSpectralProperties(network, matrixType, eigenRange) {
            const size = network.adjacencyMatrix.length;
            let matrix = JSON.parse(JSON.stringify(network.adjacencyMatrix)); // Deep copy

            // Compute matrix type
            if (matrixType === 'laplacian') {
                // Degree matrix
                const degrees = matrix.map(row => row.reduce((sum, val) => sum + val, 0));
                const degreeMatrix = degrees.map(deg => new Array(size).fill(0));
                for (let i = 0; i < size; i++) {
                    degreeMatrix[i][i] = degrees[i];
                }

                // Laplacian = Degree - Adjacency
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        matrix[i][j] = degreeMatrix[i][j] - matrix[i][j];
                    }
                }
            } else if (matrixType === 'normalized') {
                // Normalized Laplacian
                const degrees = matrix.map(row => row.reduce((sum, val) => sum + val, 0));
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        if (i === j) {
                            matrix[i][j] = 1;
                        } else if (degrees[i] > 0 && degrees[j] > 0) {
                            matrix[i][j] = -matrix[i][j] / Math.sqrt(degrees[i] * degrees[j]);
                        }
                    }
                }
            }

            // Simplified eigenvalue computation (power iteration for largest eigenvalues)
            const eigenvalues = [];
            const eigenvectors = [];

            // For demonstration, compute a few eigenvalues using simplified method
            for (let k = 0; k < Math.min(eigenRange, size); k++) {
                const { eigenvalue, eigenvector } = powerIteration(matrix, k > 0 ? eigenvectors : null);
                eigenvalues.push(eigenvalue);
                eigenvectors.push(eigenvector);
            }

            return { eigenvalues, eigenvectors, matrix };
        }

        function powerIteration(matrix, previousVectors) {
            const size = matrix.length;
            let vector = new Array(size).fill(0);
            vector[0] = 1; // Initial guess

            // Deflate previous eigenvectors
            if (previousVectors) {
                for (const prevVector of previousVectors) {
                    const dotProduct = vector.reduce((sum, val, i) => sum + val * prevVector[i], 0);
                    for (let i = 0; i < size; i++) {
                        vector[i] -= dotProduct * prevVector[i];
                    }
                }
            }

            // Normalize
            const norm = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
            vector = vector.map(val => val / norm);

            // Power iteration
            for (let iter = 0; iter < 50; iter++) {
                // Matrix-vector multiplication
                const newVector = new Array(size).fill(0);
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        newVector[i] += matrix[i][j] * vector[j];
                    }
                }

                // Normalize
                const newNorm = Math.sqrt(newVector.reduce((sum, val) => sum + val * val, 0));
                vector = newVector.map(val => val / newNorm);
            }

            // Compute Rayleigh quotient for eigenvalue
            let eigenvalue = 0;
            const mv = new Array(size).fill(0);
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    mv[i] += matrix[i][j] * vector[j];
                }
            }
            eigenvalue = vector.reduce((sum, val, i) => sum + val * mv[i], 0);

            return { eigenvalue, eigenvector: vector };
        }

        function updateNetworkVisualization(network) {
            // Update node positions
            networkChart.data.datasets[0].data = network.nodes.map(node => ({
                x: node.x,
                y: node.y
            }));

            // Update edges
            const edgeData = [];
            network.edges.forEach(edge => {
                const source = network.nodes[edge.source];
                const target = network.nodes[edge.target];
                edgeData.push({ x: source.x, y: source.y });
                edgeData.push({ x: target.x, y: target.y });
                edgeData.push({ x: null, y: null }); // Break line
            });
            networkChart.data.datasets[1].data = edgeData;

            networkChart.update();
        }

        function updateEigenvalueVisualization(eigenvalues, range) {
            eigenvalueChart.data.labels = eigenvalues.slice(0, range).map((_, i) => `Œª${i + 1}`);
            eigenvalueChart.data.datasets[0].data = eigenvalues.slice(0, range);
            eigenvalueChart.update();
        }

        function updateAdjacencyVisualization(adjacencyMatrix) {
            const data = [];
            const size = adjacencyMatrix.length;
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (adjacencyMatrix[i][j] > 0) {
                        data.push({ x: i, y: j });
                    }
                }
            }
            adjacencyChart.data.datasets[0].data = data;
            adjacencyChart.update();
        }

        function updateNetworkMetrics(network, spectralData) {
            const size = network.nodes.length;

            // Clustering coefficient
            let totalClustering = 0;
            for (let i = 0; i < size; i++) {
                const neighbors = [];
                for (let j = 0; j < size; j++) {
                    if (network.adjacencyMatrix[i][j] > 0) {
                        neighbors.push(j);
                    }
                }

                if (neighbors.length >= 2) {
                    let triangles = 0;
                    for (let k = 0; k < neighbors.length; k++) {
                        for (let l = k + 1; l < neighbors.length; l++) {
                            if (network.adjacencyMatrix[neighbors[k]][neighbors[l]] > 0) {
                                triangles++;
                            }
                        }
                    }
                    const possibleTriangles = neighbors.length * (neighbors.length - 1) / 2;
                    totalClustering += possibleTriangles > 0 ? triangles / possibleTriangles : 0;
                }
            }
            const clusteringCoeff = size > 0 ? totalClustering / size : 0;

            // Average path length (simplified)
            const avgPathLength = Math.log(size) / Math.log(2); // Approximation

            // Spectral gap
            const spectralGap = spectralData.eigenvalues.length >= 2 ?
                spectralData.eigenvalues[1] - spectralData.eigenvalues[0] : 0;

            // Algebraic connectivity (second smallest eigenvalue of Laplacian)
            const algebraicConn = spectralData.eigenvalues.length >= 2 ?
                spectralData.eigenvalues[1] : 0;

            // Network diameter (simplified)
            const networkDiameter = Math.ceil(Math.log2(size));

            // Robustness score (based on spectral gap and connectivity)
            const robustnessScore = (spectralGap + algebraicConn) / 2;

            // Update display
            document.getElementById('clusteringCoeff').textContent = clusteringCoeff.toFixed(3);
            document.getElementById('avgPathLength').textContent = avgPathLength.toFixed(2);
            document.getElementById('spectralGap').textContent = spectralGap.toFixed(3);
            document.getElementById('algebraicConn').textContent = algebraicConn.toFixed(3);
            document.getElementById('networkDiameter').textContent = networkDiameter;
            document.getElementById('robustnessScore').textContent = robustnessScore.toFixed(3);
        }

        // Initialize circadian charts with default values
        analyzeCircadianRhythm();
    </script>

    <script>
        // Navigation functionality
        document.addEventListener('DOMContentLoaded', function() {
            const navigationLinks = document.querySelectorAll('#navigation a');
            
            navigationLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    // Remove active class from all links
                    navigationLinks.forEach(l => l.classList.remove('active'));
                    
                    // Add active class to clicked link
                    this.classList.add('active');
                    
                    // Smooth scroll to target section
                    const targetId = this.getAttribute('href').substring(1);
                    const targetSection = document.getElementById(targetId);
                    
                    if (targetSection) {
                        targetSection.scrollIntoView({ 
                            behavior: 'smooth',
                            block: 'start'
                        });
                    }
                });
            });
            
            // Set initial active state
            const firstLink = document.querySelector('#navigation a');
            if (firstLink) {
                firstLink.classList.add('active');
            }
        });
    </script>
</body>
</html>
